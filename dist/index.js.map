{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///external \"chalk\"","webpack:///external \"path\"","webpack:///external \"util\"","webpack:///external \"lodash/filter\"","webpack:///external \"lodash/flatMap\"","webpack:///external \"lodash/reduce\"","webpack:///external \"winston\"","webpack:///external \"os\"","webpack:///external \"lodash/map\"","webpack:///external \"tabtab\"","webpack:///external \"fs\"","webpack:///external \"lodash/kebabCase\"","webpack:///external \"lodash/replace\"","webpack:///external \"lodash/invert\"","webpack:///external \"lodash/zipObject\"","webpack:///external \"table\"","webpack:///external \"events\"","webpack:///external \"lodash/mapKeys\"","webpack:///external \"lodash/camelCase\"","webpack:///external \"lodash/isNumber\"","webpack:///external \"lodash/sortBy\"","webpack:///external \"lodash/findIndex\"","webpack:///external \"lodash/fp/filter\"","webpack:///external \"lodash/fp/map\"","webpack:///external \"wrap-ansi\"","webpack:///external \"lodash/pickBy\"","webpack:///external \"glob\"","webpack:///./utils/version.ts","webpack:///./utils sync","webpack:///./error/base.ts","webpack:///./error/action.ts","webpack:///./logger/index.ts","webpack:///./error/fatal.ts","webpack:///./error/invalid-validator.ts","webpack:///./error/missing-argument.ts","webpack:///./error/missing-flag.ts","webpack:///./utils/colorize.ts","webpack:///./error/multi-validation.ts","webpack:///./error/no-action.ts","webpack:///./error/option-synopsis-syntax.ts","webpack:///./types.ts","webpack:///./option/utils.ts","webpack:///./validator/utils.ts","webpack:///./help/utils.ts","webpack:///./help/templates/command.ts","webpack:///./help/templates/header.ts","webpack:///./help/templates/program.ts","webpack:///./help/templates/usage.ts","webpack:///./help/templates/custom.ts","webpack:///./help/index.ts","webpack:///./parser/index.ts","webpack:///./command/import.ts","webpack:///./command/find.ts","webpack:///./autocomplete/index.ts","webpack:///./option/index.ts","webpack:///./utils/levenshtein.ts","webpack:///./utils/suggest.ts","webpack:///./error/unknown-option.ts","webpack:///./error/unknown-command.ts","webpack:///./error/validation.ts","webpack:///./error/too-many-arguments.ts","webpack:///./validator/caporal.ts","webpack:///./validator/validate.ts","webpack:///./validator/function.ts","webpack:///./validator/regexp.ts","webpack:///./validator/array.ts","webpack:///./argument/validate.ts","webpack:///./argument/find.ts","webpack:///./option/validate.ts","webpack:///./option/find.ts","webpack:///./argument/index.ts","webpack:///./argument/synopsis.ts","webpack:///./option/mapping.ts","webpack:///./config/index.ts","webpack:///./command/index.ts","webpack:///./command/validate-call.ts","webpack:///./command/scan.ts","webpack:///./utils/fs.ts","webpack:///./program/index.ts","webpack:///./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","detectVersion","path","join","__filename","version","e","webpackEmptyContext","req","Error","code","keys","resolve","id","BaseError","constructor","message","meta","super","setPrototypeOf","this","captureStackTrace","ActionError","error","caporalFormat","format","printf","data","level","prefix","levelStr","logger","colorsEnabled","chalk","bold","redBright","hex","dim","getLevelString","metaStr","for","length","inspect","showHidden","colors","formatMeta","EOL","spaces","repeat","paddingLeft","replace","RegExp","winstonCreateLogger","transports","Console","combine","splat","disableColors","supportsColor","createDefaultLogger","fatalError","log","stack","process","exitCode","InvalidValidatorError","validator","MissingArgumentError","argument","command","MissingFlagError","flag","allNotations","colorize","text","match","keyword","green","ValidationSummaryError","cmd","errors","map","synopsis","NoActionError","isProgramCommand","OptionSynopsisSyntaxError","CaporalValidator","OptionValueType","REG_SHORT_OPT","REG_LONG_OPT","REG_OPT","camelCaseOpt","camelCase","getCleanNameFromNotation","str","camelCased","getDashedOpt","Math","min","kebabCase","isNumeric","isNaN","parseFloat","isFinite","Number","isOptionStr","undefined","test","formatOptName","parseOptionSynopsis","analysis","variadic","valueType","None","valueRequired","allNames","notation","infos","split","reduce","acc","longNotation","longName","substring","push","isShortOpt","Optional","substr","Required","shortNotation","shortName","isCaporalValidator","values","filter","isNumber","a","b","isNumericValidator","Boolean","NUMBER","isStringValidator","STRING","isBoolValidator","BOOLEAN","checkValidator","checkCaporalValidator","Array","isArray","checkUserDefinedValidator","getTypeHint","obj","hint","boolean","default","stringified","JSON","stringify","buildTable","options","table","border","getBorderCharacters","columnDefault","paddingRight","columns","0","width","1","wrapWord","drawHorizontalLine","getDefaultValueHint","getOptionsTable","ctx","title","eol","crlf","opt","def","more","typeHint","required","getOptionSynopsisHelp","description","async","globalOptions","globalFlags","eol3","tpl","sortBy","from","args","eol2","desc","getArgumentsTable","header","prog","env","getVersion","getName","getBin","getDescription","program","commands","getAllCommands","getSynopsis","cmdHint","visible","getCommandsTable","usage","hasCommands","progCommand","custom","customHelp","indent","txt","sectionName","subtxt","templates","Map","entries","allTemplates","customHelpMap","customizeHelp","opts","set","registerTemplate","template","getHelp","getGlobalOptions","sp","trim","getContext","isDdash","autoCast","val","cast","cleanName","string","includes","castAsString","parseLine","line","parseArgv","Tree","argv","cursor","toJSON","ddashHandled","current","markDdashHandled","hasDdashHandled","next","slice","start","end","sliceFromHere","forward","by","ArgumentParser","config","rawArgv","ddash","inVariadicContext","argsLen","variadicId","tree","String","pushVariadic","until","indexOf","findIndex","getNextOptPosition","visit","OptionParser","rawOptions","handleOptWithoutValue","nextIsOptOrUndef","compute","handleConcatenatedOpts","names","last","alias","isBoolean","computeMulti","rawval","concatOpts","no","isVariadic","prop","concat","multi","forEach","index","parseOpts","invert","flagParser","argParser","visitors","some","v","requireFunc","__non_webpack_require__","importCommand","file","dir","parse","filename","mod","findCommand","getCommands","findRegisteredCommand","search","find","hasAlias","foundCommand","startsWith","discoverCommand","discoveryPath","fullPath","createCommand","completions","createOption","hidden","syno","kind","choices","showHelp","help","console","emit","showVersion","setVerbose","setQuiet","setSilent","silent","installComp","tabtab","install","completer","installCompletion","uninstallComp","uninstall","uninstallCompletion","setupGlobalOptions","verbose","quiet","color","installCompOpt","uninstallCompOpt","processGlobalOptions","parsed","actionsParams","promises","action","findGlobalOptAction","Promise","all","levenshtein","cell","lcell","dcell","row","j","sortByDistance","distance","keepMeaningfulSuggestions","getSuggestions","input","possibilities","suggestion","possibilitesMapper","sort","boldDiffString","to","char","charAt","greenBright","UnknownOptionError","longFlags","f","getFlagNames","suggestions","msg","UnknownOrUnspecifiedCommandError","flatMap","getAliases","wrap","whiteBright","isOptionObject","ValidationError","context","varName","underline","toString","TooManyArgumentsError","range","argsCount","expArgsStr","max","cmdName","validateWithCaporal","skipArrayValidation","ARRAY","isArrayValidator","el","validateArrayFlag","validateNumericFlag","validateStringFlag","validateBoolFlag","validate","validateWithFunction","validateWithRegExp","validateWithArray","checkRequiredArgs","parsedArgv","arg","strictArgsCount","numArgsError","getRequiredArgsCount","hasVariadicArgument","Infinity","getArgsRange","checkNumberOfArgs","removeCommandFromArgs","words","validateArgs","formatedArgs","argsObj","getArgsObjectFromArray","validations","findArgument","validateArg","result","prevPromise","collection","validateOptions","applyDefaults","findGlobalOption","findOption","validateOption","strictOptions","checkRequiredOpts","createArgument","defaultValue","rawName","isRequired","endsWith","parseArgumentSynopsis","getOptsMapping","aliases","zipObject","pickBy","createConfigurator","defaults","_defaults","reset","getAll","props","assign","Command","_name","_config","_aliases","_lastAddedArgOrOpt","_action","defaultCommand","isHelpCommand","hide","configure","option","getParserConfig","parserOpts","getConfigProperty","complete","argOrOpt","registerCompletion","strict","enabled","parsedArgs","parsedFlags","flags","flagsErrors","argsErrors","validateCall","err","ctor","getPrototypeOf","scanCommands","dirPath","files","extensions","reject","fs","existsSync","glob","cwd","readdir","imp","cmdBuilder","Program","EventEmitter","_bin","basename","_version","logLevelEnvVar","setupHelpCommand","setupErrorHandlers","once","_programmaticMode","on","_progCommand","actionParams","_discoveryPath","ver","_description","bin","disableGlobalOption","delete","warn","discoveredCommands","getLogLevelOverride","global","addGlobalOption","discover","stat","statSync","isDirectory","_discoveredCommands","CAPORAL_CMD_LINE","_run","loggerLevel","levels","processedResult","ret","run","mapKeys"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 29);\n","module.exports = require(\"chalk\");","module.exports = require(\"path\");","module.exports = require(\"util\");","module.exports = require(\"lodash/filter\");","module.exports = require(\"lodash/flatMap\");","module.exports = require(\"lodash/reduce\");","module.exports = require(\"winston\");","module.exports = require(\"os\");","module.exports = require(\"lodash/map\");","module.exports = require(\"tabtab\");","module.exports = require(\"fs\");","module.exports = require(\"lodash/kebabCase\");","module.exports = require(\"lodash/replace\");","module.exports = require(\"lodash/invert\");","module.exports = require(\"lodash/zipObject\");","module.exports = require(\"table\");","module.exports = require(\"events\");","module.exports = require(\"lodash/mapKeys\");","module.exports = require(\"lodash/camelCase\");","module.exports = require(\"lodash/isNumber\");","module.exports = require(\"lodash/sortBy\");","module.exports = require(\"lodash/findIndex\");","module.exports = require(\"lodash/fp/filter\");","module.exports = require(\"lodash/fp/map\");","module.exports = require(\"wrap-ansi\");","module.exports = require(\"lodash/pickBy\");","module.exports = require(\"glob\");","/**\n * @packageDocumentation\n * @internal\n */\nimport path from \"path\"\n\nexport function detectVersion(): string | undefined {\n  try {\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return require(path.join(__filename, \"..\", \"..\", \"..\", \"package.json\")).version\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 28;","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { ErrorMetadata } from \"../types\"\n\nexport class BaseError extends Error {\n  public meta: ErrorMetadata\n\n  constructor(message: string, meta: ErrorMetadata = {}) {\n    super(message)\n    Object.setPrototypeOf(this, new.target.prototype)\n    this.name = this.constructor.name\n    this.meta = meta\n    Error.captureStackTrace(this, this.constructor)\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\n\nexport class ActionError extends BaseError {\n  constructor(error: string | Error) {\n    const message = typeof error === \"string\" ? error : error.message\n    super(message, { error })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { createLogger as winstonCreateLogger, transports, format } from \"winston\"\nimport { inspect } from \"util\"\nimport { default as chalk, supportsColor } from \"chalk\"\nimport type { Logger } from \"../types\"\nimport replace from \"lodash/replace\"\nimport { EOL } from \"os\"\n\nconst caporalFormat = format.printf((data) => {\n  const { level, ...meta } = data\n  let { message } = data\n  let prefix = \"\"\n\n  const levelStr = getLevelString(level)\n  const metaStr = formatMeta(meta)\n\n  if (metaStr !== \"\") {\n    message += `${EOL}${levelStr}: ${metaStr}`\n  }\n\n  if (level === \"error\") {\n    const spaces = \" \".repeat(meta.paddingLeft || 7)\n    prefix = EOL\n    message = `${replace(message, new RegExp(EOL, \"g\"), EOL + spaces)}${EOL}`\n  }\n\n  return `${prefix}${levelStr}: ${message}`\n})\n\nfunction formatMeta(meta: Record<string, unknown>): string {\n  delete meta.message\n  delete meta[(Symbol.for(\"level\") as unknown) as string]\n  delete meta[(Symbol.for(\"message\") as unknown) as string]\n  delete meta[(Symbol.for(\"splat\") as unknown) as string]\n  if (Object.keys(meta).length) {\n    return inspect(meta, {\n      showHidden: false,\n      colors: logger.colorsEnabled,\n    })\n  }\n  return \"\"\n}\n\nfunction getLevelString(level: string): string {\n  if (!logger.colorsEnabled) {\n    return level\n  }\n  let levelStr = level\n  switch (level) {\n    case \"error\":\n      levelStr = chalk.bold.redBright(level)\n      break\n    case \"warn\":\n      levelStr = chalk.hex(\"#FF9900\")(level)\n      break\n    case \"info\":\n      levelStr = chalk.hex(\"#569cd6\")(level)\n      break\n    case \"debug\":\n    case \"silly\":\n      levelStr = chalk.dim(level)\n      break\n  }\n  return levelStr\n}\n\nexport let logger: Logger = createDefaultLogger()\n\nexport function setLogger(loggerObj: Logger): void {\n  logger = loggerObj\n}\n\nexport function getLogger(): Logger {\n  return logger\n}\n\nexport function createDefaultLogger(): Logger {\n  const logger = winstonCreateLogger({\n    transports: [\n      new transports.Console({\n        format: format.combine(format.splat(), caporalFormat),\n      }),\n    ],\n  }) as Logger\n  // disableColors() disable on the logger level,\n  // while chalk supports the --color/--no-color flag\n  // as well as the FORCE_COLOR env var\n  logger.disableColors = () => {\n    logger.transports[0].format = caporalFormat\n    logger.colorsEnabled = false\n  }\n  logger.colorsEnabled = supportsColor !== false\n  return logger\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { logger } from \"../logger\"\nimport type { BaseError } from \"./base\"\n\n/**\n * @param err - Error object\n */\nexport function fatalError(error: BaseError): void {\n  if (logger.level == \"debug\") {\n    logger.log({\n      level: \"error\",\n      ...error,\n      message: error.message + \"\\n\\n\" + error.stack,\n      stack: error.stack,\n      name: error.name,\n    })\n  } else {\n    logger.error(error.message)\n  }\n  process.exitCode = 1\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Validator } from \"../types\"\nexport class InvalidValidatorError extends BaseError {\n  constructor(validator: Validator) {\n    super(\"Caporal setup error: Invalid flag validator setup.\", { validator })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\nimport { Argument } from \"../types\"\nimport chalk from \"chalk\"\n\nexport class MissingArgumentError extends BaseError {\n  constructor(argument: Argument, command: Command) {\n    const msg = `Missing required argument ${chalk.bold(argument.name)}.`\n    super(msg, { argument, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\nimport { Option } from \"../types\"\nimport chalk from \"chalk\"\n\nexport class MissingFlagError extends BaseError {\n  constructor(flag: Option, command: Command) {\n    const msg = `Missing required flag ${chalk.bold(flag.allNotations.join(\" | \"))}.`\n    super(msg, { flag, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport c from \"chalk\"\n\nexport function colorize(text: string): string {\n  return text\n    .replace(/<([^>]+)>/gi, (match) => {\n      return c.hex(\"#569cd6\")(match)\n    })\n    .replace(/<command>/gi, (match) => {\n      return c.keyword(\"orange\")(match)\n    })\n    .replace(/\\[([^[\\]]+)\\]/gi, (match) => {\n      return c.hex(\"#aaa\")(match)\n    })\n    .replace(/ --?([^\\s,]+)/gi, (match) => {\n      return c.green(match)\n    })\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport chalk from \"chalk\"\nimport { colorize } from \"../utils/colorize\"\nimport type { Command } from \"../command\"\n\nexport class ValidationSummaryError extends BaseError {\n  constructor(cmd: Command, errors: BaseError[]) {\n    const plural = errors.length > 1 ? \"s\" : \"\"\n    const msg =\n      `The following error${plural} occured:\\n` +\n      errors.map((e) => \"- \" + e.message.replace(/\\n/g, \"\\n  \")).join(\"\\n\") +\n      \"\\n\\n\" +\n      chalk.dim(\"Synopsis: \") +\n      colorize(cmd.synopsis)\n    super(msg, { errors })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { Command } from \"../command\"\n\nexport class NoActionError extends BaseError {\n  constructor(cmd?: Command) {\n    let message\n    if (cmd && !cmd.isProgramCommand()) {\n      message = `Caporal Error: You haven't defined any action for command '${cmd.name}'.\\nUse .action() to do so.`\n    } else {\n      message = `Caporal Error: You haven't defined any action for program.\\nUse .action() to do so.`\n    }\n    super(message, { cmd })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\n\nexport class OptionSynopsisSyntaxError extends BaseError {\n  constructor(synopsis: string) {\n    super(`Syntax error in option synopsis: ${synopsis}`, { synopsis })\n  }\n}\n","/**\n * List of Caporal type aliases.\n *\n * @packageDocumentation\n * @module caporal/types\n */\n//\nimport { Logger as WinstonLogger } from \"winston\"\nimport { Program } from \"./program\"\nimport { Command } from \"./command\"\nimport { BaseError } from \"./error\"\n\n/**\n * The Caporal logger interface. It extends the [Winston](https://github.com/winstonjs/winston) Logger interface\n * and adds the following properties & methods.\n * @noInheritDoc\n */\nexport interface Logger extends WinstonLogger {\n  /**\n   * Allow to force disabling colors.\n   */\n  disableColors(): void\n  /**\n   * Tells Caporal if colors are enabled or not.\n   */\n  colorsEnabled: boolean\n}\n\nexport type GlobalOptions = Map<Option, Action | undefined>\n\n/**\n * Caporal-provided validator flags.\n */\nexport enum CaporalValidator {\n  /**\n   * Number validator. Check that the value looks like a numeric one\n   * and cast the provided value to a javascript `Number`.\n   */\n  NUMBER = 1,\n  /**\n   * Boolean validator. Check that the value looks like a boolean.\n   * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`\n   * and will auto-cast those values to `true` or `false`.\n   */\n  BOOLEAN = 2,\n  /**\n   * String validator. Mainly used to make sure the value is a string,\n   * and prevent Caporal auto-casting of numerics values and boolean\n   * strings like `true` or `false`.\n   */\n  STRING = 4,\n  /**\n   * Array validator. Convert any provided value to an array. If a string is provided,\n   * this validator will try to split it by commas.\n   */\n  ARRAY = 8,\n}\n\ntype FunctionValidatorArgument = ParsedArgument | ParsedOption\n\n// export type FunctionValidator<T = FunctionValidatorArgument> = (\n//   value: T,\n// ) => FunctionValidatorArgument | Promise<FunctionValidatorArgument>\n\nexport interface FunctionValidator<T = FunctionValidatorArgument> {\n  (value: T): Promisable<T>\n}\n\n// export type FunctionValidator<T = FunctionValidatorArgument> = (value: T) => Promisable<T>\n\nexport type Validator = RegExp | FunctionValidator | CaporalValidator | ParserTypes[]\n\n/**\n * @internal\n */\nexport interface ValidatorWrapper {\n  validate(\n    value: ParsedArgument | ParsedOption,\n  ): ParserTypes | ParserTypes[] | Promise<ParserTypes>\n  getChoices(): ParserTypes[]\n}\n\nexport interface OptionSynopsis {\n  name: string\n  notation: string\n  shortName?: string\n  shortNotation?: string\n  longName?: string\n  longNotation?: string\n  allNames: string[]\n  allNotations: string[]\n  synopsis: string\n  valueRequired: boolean\n  valueType?: OptionValueType\n  variadic: boolean\n}\n\n/**\n * Option possible value.\n *\n */\nexport enum OptionValueType {\n  /**\n   * Value is optional.\n   */\n  Optional,\n  /**\n   * Value is required.\n   */\n  Required,\n  /**\n   * Option does not have any possible value\n   */\n  None,\n}\n\n/**\n * Option properties\n */\nexport interface CreateOptionCommandOpts {\n  /**\n   * Optional validator\n   */\n  validator?: Validator\n  /**\n   * Default value for the Option\n   */\n  default?: ParsedOption\n  /**\n   * Set the Option as itself required\n   */\n  required?: boolean\n  /**\n   * Hide the option from help\n   */\n  hidden?: boolean\n}\n\n/**\n * Option properties\n */\nexport interface CreateOptionProgramOpts extends CreateOptionCommandOpts {\n  /**\n   * Set to `true` for a global option.\n   */\n  global?: boolean\n  /**\n   * Action to call when a global-option is passed.\n   * Only available for global options, e.g. when `global` is set to `true`.\n   */\n  action?: Action\n}\n\nexport interface CreateArgumentOpts {\n  /**\n   * Argument validator.\n   */\n  validator?: Validator\n  /**\n   * Argument default value.\n   */\n  default?: ParsedArgument\n}\n\nexport interface ArgumentSynopsis {\n  /**\n   * Argument name.\n   */\n  readonly name: string\n  /**\n   * Boolean indicating if the argument is required.\n   */\n  readonly required: boolean\n  /**\n   * Synopsis string.\n   */\n  readonly synopsis: string\n  /**\n   * Boolean indicating if the argument is valiadic,\n   * e.g. can be repeated to contain an array of values.\n   */\n  readonly variadic: boolean\n}\n\nexport interface Argument extends ArgumentSynopsis {\n  readonly default?: ParsedArgument\n  readonly description: string\n  readonly choices: ParsedArgument[]\n  readonly validator?: Validator\n  typeHint?: string\n  kind: \"argument\"\n}\n\nexport interface Option extends OptionSynopsis {\n  readonly boolean: boolean\n  readonly default?: ParsedOption\n  readonly description: string\n  readonly choices: ParsedOption[]\n  readonly validator?: Validator\n  readonly required: boolean\n  readonly visible: boolean\n  typeHint?: string\n  kind: \"option\"\n}\n\n/**\n * A type that could be wrapped in a Promise, or not\n */\nexport type Promisable<T> = T | Promise<T>\n\n/**\n * Parameters object passed to an {@link Action} function\n */\nexport interface ActionParameters {\n  /**\n   * Parsed command line arguments\n   */\n  args: ParsedArgumentsObject\n  /**\n   * If the `dash` (double dash) config property is enabled,\n   * this *array* will contain all arguments present\n   * after '--'.\n   */\n  ddash: ParsedArguments\n  /**\n   * Parsed command line options\n   */\n  options: ParsedOptions\n  /**\n   * Program instance\n   */\n  program: Program\n  /**\n   * Contextual command, if any\n   */\n  command?: Command\n  /**\n   * Logger instance\n   */\n  logger: Logger\n}\n\n/**\n * An action is a function that will be executed upon a command call.\n */\nexport interface Action {\n  (params: ActionParameters): unknown\n}\n\nexport interface ErrorMetadata {\n  [meta: string]: unknown\n}\n\nexport type ParserTypes = string | number | boolean\n\n/**\n * Available options for the Caporal internal parser.\n * Arguments must be referenced by their position (0-based) and options by their name (short or long)\n * in {@link ParserOptions.boolean boolean}, {@link ParserOptions.string string}\n * and {@link ParserOptions.variadic variadic} parser options.\n *\n */\nexport interface ParserOptions {\n  /**\n   * List of {@link Argument Arguments} and {@link Options Options} to be casted as *booleans*.\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  boolean: [2, 'sendEmail']\n   * })\n   *\n   * // ./my-cli-app first-arg second-arg 3rd-arg --sendEmail=1\n   * // -> \"3rd-arg\" will be casted to boolean as well as \"--sendEmail\"\n   * ```\n   */\n  boolean: (string | number)[]\n  /**\n   * List of {@link Argument Arguments} and {@link Options Options} to be casted as *strings*.\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  string: [1]\n   * })\n   *\n   * // ./my-cli-app first-arg 2\n   * // -> second arg \"2\" will be casted to string instead of number\n   * ```\n   */\n  string: (string | number)[]\n  /**\n   * List of variadic {@link Argument Arguments} and {@link Options Options}, meaning\n   * that there value is an `Array`.\n   *\n   * Arguments must be referenced by their position (0-based) and options by their name (short or long).\n   *\n   * **Example**\n   *\n   * ```ts\n   * import { parseArgv } from \"caporal/parser\"\n   *\n   * parseArgv({\n   *  variadic: [1]\n   * })\n   *\n   * // ./pizza order margherita regina --add sausages --add basil\n   * {\n   *   args: ['order', ['margherita', 'regina']]\n   *   options: {\n   *     add: ['sausages', 'basil']\n   *   }\n   * }\n   * ```\n   */\n  variadic: (string | number)[]\n  /**\n   * Double-dash (--) handling mode. If `true`, the parser will populate the\n   * {@link ParserResult.ddash} property, otherwise, arguments will be added\n   * to {@link ParserResult.args}.\n   */\n  ddash: boolean\n  /**\n   * Option aliases map.\n   */\n  alias: Record<string, string>\n  /**\n   * Enable or disable autocasting of arguments and options. Default to `true`.\n   */\n  autoCast: boolean\n}\n\nexport type ParsedArgument = ParserTypes | ParserTypes[]\nexport type ParsedArguments = ParsedArgument[]\nexport interface ParsedArgumentsObject {\n  [arg: string]: ParsedArgument\n}\n\nexport type ParsedOption = ParserTypes | ParserTypes[]\nexport interface ParsedOptions {\n  [opt: string]: ParsedOption\n}\n/**\n * @internal\n */\nexport interface ArgumentsRange {\n  min: number\n  max: number\n}\n\nexport interface ParserResult {\n  args: ParsedArguments\n  options: ParsedOptions\n  rawOptions: ParsedOptions\n  line: string\n  rawArgv: string[]\n  ddash: ParsedArguments\n}\n\nexport interface ParserProcessedResult extends Omit<ParserResult, \"args\"> {\n  args: ParsedArgumentsObject\n  errors: BaseError[]\n}\n\nexport interface CreateCommandParameters {\n  program: Program\n  createCommand(description?: string): Command\n}\nexport interface CommandCreator {\n  (options: CreateCommandParameters): Command\n}\n\n/**\n * Available configuration properties for the program.\n */\nexport interface ProgramConfig {\n  /**\n   * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.\n   * Default to `true`.\n   */\n  strictArgsCount: boolean\n  /**\n   * Strict checking of options provided. If enabled, any unknown option will trigger an error.\n   * Default to `true`.\n   */\n  strictOptions: boolean\n  /**\n   * Auto-casting of arguments and options.\n   * Default to `true`.\n   */\n  autoCast: boolean\n  /**\n   * Environment variable to check for log level override.\n   * Default to \"CAPORAL_LOG_LEVEL\".\n   */\n  logLevelEnvVar: string\n}\nexport interface CommandConfig {\n  /**\n   * Strict checking of arguments count. If enabled, any additional argument willl trigger an error.\n   */\n  strictArgsCount?: boolean\n  /**\n   * Strict checking of options provided. If enabled, any unknown option will trigger an error.\n   */\n  strictOptions?: boolean\n  /**\n   * Auto-casting of arguments and options.\n   */\n  autoCast?: boolean\n  /**\n   * Visibility of the command in help.\n   */\n  visible: boolean\n}\n\nexport interface Configurator<T extends {}> {\n  get<K extends keyof T>(key: K): T[K]\n  getAll(): T\n  set(props: Partial<T>): T\n  reset(): T\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport camelCase from \"lodash/camelCase\"\nimport kebabCase from \"lodash/kebabCase\"\nimport { OptionSynopsisSyntaxError } from \"../error\"\nimport { OptionValueType } from \"../types\"\nimport type { OptionSynopsis, ParserTypes } from \"../types\"\n\nconst REG_SHORT_OPT = /^-[a-z]$/i\nconst REG_LONG_OPT = /^--[a-z]{2,}/i\nconst REG_OPT = /^(-[a-zA-Z]|--\\D{1}[\\w-]+)/\n\nfunction isShortOpt(flag: string): boolean {\n  return REG_SHORT_OPT.test(flag)\n}\n\nfunction isLongOpt(flag: string): boolean {\n  return REG_LONG_OPT.test(flag)\n}\n\n/**\n * Specific version of camelCase which does not lowercase short flags\n *\n * @param name Flag short or long name\n */\nfunction camelCaseOpt(name: string): string {\n  return name.length === 1 ? name : camelCase(name)\n}\n\nexport function getCleanNameFromNotation(str: string, camelCased = true): string {\n  str = str\n    .replace(/([[\\]<>]+)/g, \"\")\n    .replace(\"...\", \"\")\n    .replace(/^no-/, \"\")\n  return camelCased ? camelCaseOpt(str) : str\n}\n\nexport function getDashedOpt(name: string): string {\n  const l = Math.min(name.length, 2)\n  return \"-\".repeat(l) + kebabCase(name)\n}\n\nexport function isNumeric(n: string): boolean {\n  return !isNaN(parseFloat(n)) && isFinite(Number(n))\n}\n\nexport function isOptionStr(str?: string): str is string {\n  return str !== undefined && str !== \"--\" && REG_OPT.test(str)\n}\n\nexport function isConcatenatedOpt(str: string): string[] | false {\n  if (str.match(/^-([a-z]{2,})/i)) {\n    return str.substr(1).split(\"\")\n  }\n  return false\n}\n\nexport function isNegativeOpt(opt: string): boolean {\n  return opt.substr(0, 5) === \"--no-\"\n}\n\nexport function isOptArray(flag: ParserTypes | ParserTypes[]): flag is ParserTypes[] {\n  return Array.isArray(flag)\n}\n\nexport function formatOptName(name: string): string {\n  return camelCaseOpt(name.replace(/^--?(no-)?/, \"\"))\n}\n\n/**\n * Parse a option synopsis\n *\n * @example\n * parseSynopsis(\"-f, --file <path>\")\n * // Returns...\n * {\n *    longName: 'file',\n *    longNotation: '--file',\n *    shortNotation: '-f',\n *    shortName: 'f'\n *    valueType: 0, // 0 = optional, 1 = required, 2 = no value\n *    variadic: false\n *    name: 'file'\n *    notation: '--file' // either the long or short notation\n * }\n *\n * @param synopsis\n * @ignore\n */\nexport function parseOptionSynopsis(synopsis: string): OptionSynopsis {\n  // synopsis = synopsis.trim()\n  const analysis: OptionSynopsis = {\n    variadic: false,\n    valueType: OptionValueType.None,\n    valueRequired: false,\n    allNames: [],\n    allNotations: [],\n    name: \"\",\n    notation: \"\",\n    synopsis,\n  }\n\n  const infos: Partial<OptionSynopsis> = synopsis\n    .split(/[\\s\\t,]+/)\n    .reduce((acc, value) => {\n      if (isLongOpt(value)) {\n        acc.longNotation = value\n        acc.longName = getCleanNameFromNotation(value.substring(2))\n        acc.allNames.push(acc.longName)\n        acc.allNotations.push(value)\n      } else if (isShortOpt(value)) {\n        acc.shortNotation = value\n        acc.shortName = value.substring(1)\n        acc.allNames.push(acc.shortName)\n        acc.allNotations.push(value)\n      } else if (value.substring(0, 1) === \"[\") {\n        acc.valueType = OptionValueType.Optional\n        acc.valueRequired = false\n        acc.variadic = value.substr(-4, 3) === \"...\"\n      } else if (value.substring(0, 1) === \"<\") {\n        acc.valueType = OptionValueType.Required\n        acc.valueRequired = true\n        acc.variadic = value.substr(-4, 3) === \"...\"\n      }\n      return acc\n    }, analysis)\n\n  if (infos.longName === undefined && infos.shortName === undefined) {\n    throw new OptionSynopsisSyntaxError(synopsis)\n  }\n\n  infos.name = infos.longName || (infos.shortName as string)\n  infos.notation = infos.longNotation || (infos.shortNotation as string)\n\n  const fullSynopsis = { ...infos } as OptionSynopsis\n\n  return fullSynopsis\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Validator } from \"../types\"\nimport { CaporalValidator, Argument, Option } from \"../types\"\nimport isNumber from \"lodash/isNumber\"\nimport { InvalidValidatorError } from \"../error\"\n\nexport function isCaporalValidator(\n  validator: Validator | undefined,\n): validator is number {\n  if (typeof validator !== \"number\") {\n    return false\n  }\n  const mask = getCaporalValidatorsMask()\n  const exist = (mask & validator) === validator\n  return exist\n}\n\nexport function isNumericValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.NUMBER)\n}\n\nexport function isStringValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.STRING)\n}\n\nexport function isBoolValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.BOOLEAN)\n}\n\nexport function isArrayValidator(validator: Validator | undefined): boolean {\n  return isCaporalValidator(validator) && Boolean(validator & CaporalValidator.ARRAY)\n}\n\nfunction getCaporalValidatorsMask(): number {\n  return Object.values(CaporalValidator)\n    .filter(isNumber)\n    .reduce((a, b) => a | b, 0)\n}\n\nfunction checkCaporalValidator(validator: CaporalValidator): void {\n  if (!isCaporalValidator(validator)) {\n    throw new InvalidValidatorError(validator)\n  }\n}\n\nfunction checkUserDefinedValidator(validator: Validator): void {\n  if (\n    typeof validator !== \"function\" &&\n    !(validator instanceof RegExp) &&\n    !Array.isArray(validator)\n  ) {\n    throw new InvalidValidatorError(validator)\n  }\n}\n\nexport function checkValidator(validator: Validator | undefined): void {\n  if (validator !== undefined) {\n    typeof validator === \"number\"\n      ? checkCaporalValidator(validator)\n      : checkUserDefinedValidator(validator)\n  }\n}\n\nexport function getTypeHint(obj: Argument | Option): string | undefined {\n  let hint\n  if (\n    isBoolValidator(obj.validator) ||\n    (\"boolean\" in obj && obj.boolean && obj.default !== false)\n  ) {\n    hint = \"boolean\"\n  } else if (isNumericValidator(obj.validator)) {\n    hint = \"number\"\n  } else if (Array.isArray(obj.validator)) {\n    const stringified = JSON.stringify(obj.validator)\n    if (stringified.length < 300) {\n      hint = \"one of \" + stringified.substr(1, stringified.length - 2)\n    }\n  }\n  return hint\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { table, getBorderCharacters } from \"table\"\nimport filter from \"lodash/filter\"\nimport type { TemplateContext } from \"./types\"\nimport type { Option, Argument } from \"../types\"\nimport type { Command } from \"../command\"\n\nexport function buildTable(data: string[][], options = {}): string {\n  return table(data, {\n    border: getBorderCharacters(`void`),\n    columnDefault: {\n      paddingLeft: 0,\n      paddingRight: 2,\n    },\n    columns: {\n      0: {\n        paddingLeft: 4,\n        width: 35,\n      },\n      1: {\n        width: 55,\n        wrapWord: true,\n        paddingRight: 0,\n      },\n    },\n    drawHorizontalLine: () => {\n      return false\n    },\n    ...options,\n  })\n}\n\nexport function getDefaultValueHint(obj: Argument | Option): string | undefined {\n  return obj.default !== undefined &&\n    !(\"boolean\" in obj && obj.boolean && obj.default === false)\n    ? \"default: \" + JSON.stringify(obj.default)\n    : undefined\n}\n\nfunction getOptionSynopsisHelp(\n  opt: Option,\n  { eol: crlf, chalk: c }: TemplateContext,\n): string {\n  return (\n    opt.synopsis +\n    (opt.required && opt.default === undefined ? crlf + c.dim(\"required\") : \"\")\n  )\n}\n\nexport function getOptionsTable(\n  options: Option[],\n  ctx: TemplateContext,\n  title = \"OPTIONS\",\n): string {\n  options = filter(options, \"visible\")\n  if (!options.length) {\n    return \"\"\n  }\n  const { chalk: c, eol: crlf, table, spaces } = ctx\n  const help = spaces + c.bold(title) + crlf + crlf\n  const rows = options.map((opt) => {\n    const def = getDefaultValueHint(opt)\n    const more = [opt.typeHint, def].filter((d) => d).join(\", \")\n    const syno = getOptionSynopsisHelp(opt, ctx)\n    const desc = opt.description + (more.length ? crlf + c.dim(more) : \"\")\n    return [syno, desc]\n  })\n  return help + table(rows)\n}\n\nexport function getArgumentsTable(\n  args: Argument[],\n  ctx: TemplateContext,\n  title = \"ARGUMENTS\",\n): string {\n  if (!args.length) {\n    return \"\"\n  }\n  const { chalk: c, eol, eol2, table, spaces } = ctx\n  const help = spaces + c.bold(title) + eol2\n  const rows = args.map((a) => {\n    const def = getDefaultValueHint(a)\n    const more = [a.typeHint, def].filter((d) => d).join(\", \")\n    const desc = a.description + (more.length ? eol + c.dim(more) : \"\")\n    return [a.synopsis, desc]\n  })\n  return help + table(rows)\n}\n\nexport function getCommandsTable(\n  commands: Command[],\n  ctx: TemplateContext,\n  title = \"COMMANDS\",\n): string {\n  const { chalk, prog, eol2, table, spaces } = ctx\n  const cmdHint = `Type '${prog.getBin()} help <command>' to get some help about a command`\n  const help =\n    spaces + chalk.bold(title) + ` ${chalk.dim(\"\\u2014\")} ` + chalk.dim(cmdHint) + eol2\n  const rows = commands\n    .filter((c) => c.visible)\n    .map((cmd) => {\n      return [chalk.keyword(\"orange\")(cmd.name), cmd.description || \"\"]\n    })\n\n  return help + table(rows)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport type { TemplateContext, Template } from \"../types\"\nimport { getOptionsTable, getArgumentsTable } from \"../utils\"\nimport sortBy from \"lodash/sortBy\"\n\nexport const command: Template = async (ctx: TemplateContext) => {\n  const { cmd, globalOptions: globalFlags, eol, eol3, colorize, tpl } = ctx\n\n  const options = sortBy(cmd!.options, \"name\"),\n    globalOptions = Array.from(globalFlags.keys())\n\n  const help =\n    cmd!.synopsis +\n    eol3 +\n    (await tpl(\"custom\", ctx)) +\n    getArgumentsTable(cmd!.args, ctx) +\n    eol +\n    getOptionsTable(options, ctx) +\n    eol +\n    getOptionsTable(globalOptions, ctx, \"GLOBAL OPTIONS\")\n\n  return colorize(help)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const header: Template = (ctx: TemplateContext) => {\n  const { prog, chalk: c, spaces, eol, eol2 } = ctx\n  const version = process.env?.NODE_ENV === \"test\" ? \"\" : prog.getVersion()\n  return (\n    eol +\n    spaces +\n    (prog.getName() || prog.getBin()) +\n    \" \" +\n    (version || \"\") +\n    (prog.getDescription() ? \" \\u2014 \" + c.dim(prog.getDescription()) : \"\") +\n    eol2\n  )\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\nimport { getOptionsTable, getCommandsTable } from \"../utils\"\n\nexport const program: Template = async (ctx: TemplateContext) => {\n  const { prog, globalOptions, eol, eol3, colorize, tpl } = ctx\n  const commands = await prog.getAllCommands()\n  const options = Array.from(globalOptions.keys())\n  const help =\n    (await prog.getSynopsis()) +\n    eol3 +\n    (await tpl(\"custom\", ctx)) +\n    getCommandsTable(commands, ctx) +\n    eol +\n    getOptionsTable(options, ctx, \"GLOBAL OPTIONS\")\n\n  return colorize(help)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const usage: Template = async (ctx: TemplateContext) => {\n  const { tpl, prog, chalk: c, spaces, eol } = ctx\n  let { cmd } = ctx\n\n  // if help is asked without a `cmd` and that no command exists\n  // within the program, override `cmd` with the program-command\n  if (!cmd && !(await prog.hasCommands())) {\n    ctx.cmd = cmd = prog.progCommand\n  }\n\n  // usage\n  const usage = `${spaces + c.bold(\"USAGE\")} ${cmd?.name ? \"— \" + c.dim(cmd.name) : \"\"}\n  ${eol + spaces + spaces + c.dim(\"\\u25B8\")} `\n\n  const next = cmd ? await tpl(\"command\", ctx) : await tpl(\"program\", ctx)\n\n  return usage + next\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { TemplateContext, Template } from \"../types\"\n\nexport const custom: Template = (ctx: TemplateContext) => {\n  const { prog, cmd, eol2, eol3, chalk, colorize, customHelp, indent } = ctx\n  const data = customHelp.get(cmd || prog)\n  if (data) {\n    const txt = data\n      .map(({ text, options }) => {\n        let str = \"\"\n        if (options.sectionName) {\n          str += chalk.bold(options.sectionName) + eol2\n        }\n        const subtxt = options.colorize ? colorize(text) : text\n        str += options.sectionName ? indent(subtxt) : subtxt\n        return str + eol3\n      })\n      .join(\"\")\n    return indent(txt) + eol3\n  }\n  return \"\"\n}\n","/**\n * @packageDocumentation\n * @module caporal/help\n */\nimport { Command } from \"../command\"\nimport { Program } from \"../program\"\nimport replace from \"lodash/replace\"\nimport chalk from \"chalk\"\nimport { buildTable } from \"./utils\"\nimport { colorize } from \"../utils/colorize\"\nimport * as allTemplates from \"./templates\"\nimport { getGlobalOptions } from \"../option\"\nimport { CustomizedHelpMap, CustomizedHelpOpts, TemplateContext, Template } from \"./types\"\n\nconst templates = new Map(Object.entries(allTemplates))\nconst customHelpMap: CustomizedHelpMap = new Map()\n\n/**\n * Customize the help\n *\n * @param obj\n * @param text\n * @param options\n * @internal\n */\nexport function customizeHelp(\n  obj: Command | Program,\n  text: string,\n  options: Partial<CustomizedHelpOpts>,\n): void {\n  const opts: CustomizedHelpOpts = {\n    sectionName: \"\",\n    colorize: true,\n    ...options,\n  }\n  const data = customHelpMap.get(obj) || []\n  data.push({ text, options: opts })\n  customHelpMap.set(obj, data)\n}\n\n/**\n * Register a new help template\n *\n * @param name Template name\n * @param template Template function\n *\n */\nexport function registerTemplate(\n  name: string,\n  template: Template,\n): Map<string, Template> {\n  return templates.set(name, template)\n}\n\n/**\n * Helper to be used to call templates from within templates\n *\n * @param name Template name\n * @param ctx Execution context\n * @internal\n */\nexport async function tpl(name: string, ctx: TemplateContext): Promise<string> {\n  const template = templates.get(name)\n  if (!template) {\n    throw Error(`Caporal setup error: Unknown help template '${name}'`)\n  }\n  return template(ctx)\n}\n\n/**\n * @internal\n * @param program\n * @param command\n */\nexport function getContext(program: Program, command?: Command): TemplateContext {\n  const spaces = \" \".repeat(2)\n  const ctx: TemplateContext = {\n    prog: program,\n    cmd: command,\n    chalk: chalk,\n    colorize: colorize,\n    customHelp: customHelpMap,\n    tpl,\n    globalOptions: getGlobalOptions(),\n    table: buildTable,\n    spaces,\n    indent(str: string, sp = spaces) {\n      return sp + replace(str.trim(), /(\\r\\n|\\r|\\n)/g, \"\\n\" + sp)\n    },\n    eol: \"\\n\",\n    eol2: \"\\n\\n\",\n    eol3: \"\\n\\n\\n\",\n  }\n  return ctx\n}\n\n/**\n * Return the help text\n *\n * @param program Program instance\n * @param command Command instance, if any\n * @internal\n */\nexport async function getHelp(program: Program, command?: Command): Promise<string> {\n  const ctx = getContext(program, command)\n  return [await tpl(\"header\", ctx), await tpl(\"usage\", ctx)].join(\"\")\n}\n","/**\n * @packageDocumentation\n * @module parser\n */\nimport invert from \"lodash/invert\"\nimport findIndex from \"lodash/findIndex\"\nimport type {\n  ParserOptions,\n  ParserResult,\n  ParserTypes,\n  ParsedOptions,\n  ParsedArguments,\n} from \"../types\"\nimport {\n  isNumeric,\n  isConcatenatedOpt,\n  isNegativeOpt,\n  isOptionStr,\n  formatOptName,\n  isOptArray,\n} from \"../option/utils\"\n\nconst DDASH = \"--\"\n\nfunction isDdash(str?: string): str is string {\n  return str === DDASH\n}\n\nfunction castAsBool(value: string | boolean): boolean {\n  if (typeof value === \"boolean\") {\n    return value\n  }\n  return /^true|1|yes|on$/.test(value)\n}\n\nfunction castAsString(val: string | boolean): string {\n  return val + \"\"\n}\n\nfunction autoCast(val: string): ParserTypes {\n  // auto-casting \"true\" & \"false\"\n  if (/^true|false$/.test(val)) {\n    return val === \"true\"\n  }\n  // auto-casting numbers\n  return isNumeric(val) ? parseFloat(val) : val\n}\n\nfunction cast(name: string, val: string | true, options: ParserOptions): ParserTypes {\n  const cleanName = formatOptName(name)\n\n  // Force casting to string\n  if (options.string.includes(cleanName)) {\n    return castAsString(val)\n  }\n\n  // Force casting to bool\n  if (options.boolean.includes(cleanName) || typeof val === \"boolean\") {\n    return castAsBool(val)\n  }\n\n  return options.autoCast ? autoCast(val) : val\n}\n\n/**\n * Parse a line\n *\n * @param line Line to be parsed\n * @param options Parser options\n * @internal\n */\nexport function parseLine(\n  line: string,\n  options: Partial<ParserOptions> = {},\n): ParserResult {\n  return parseArgv(options, line.split(\" \"))\n}\n/**\n *\n * @param args Return the next option position unless there is some ddash before\n */\nfunction getNextOptPosition(args: string[]): number {\n  const ddash = args.indexOf(\"--\")\n  const opt = findIndex(args, isOptionStr)\n  return ddash < opt && ddash !== -1 ? -1 : opt\n}\n\nclass Tree {\n  cursor: number\n  private ddashHandled = false\n\n  constructor(private argv: string[]) {\n    this.cursor = 0\n  }\n\n  /* istanbul ignore next */\n  toJSON(): {\n    cursor: number\n    ddashHandled: boolean\n    argv: string[]\n    current?: string\n  } {\n    return {\n      cursor: this.cursor,\n      ddashHandled: this.ddashHandled,\n      current: this.current,\n      argv: this.argv,\n    }\n  }\n\n  markDdashHandled(): Tree {\n    this.ddashHandled = true\n    return this\n  }\n\n  hasDdashHandled(): boolean {\n    return this.ddashHandled\n  }\n\n  next(): string | undefined {\n    return this.argv[this.cursor + 1]\n  }\n\n  slice(start?: number, end?: number): string[] {\n    return this.argv.slice(start, end)\n  }\n\n  sliceFromHere(end?: number): string[] {\n    return this.slice(this.cursor, end)\n  }\n\n  forward(by = 1): true {\n    if (by === -1) {\n      return this.end()\n    }\n    this.cursor += by\n    return true\n  }\n\n  end(): true {\n    this.cursor = this.length\n    return true\n  }\n\n  get current(): string | undefined {\n    return this.argv[this.cursor]\n  }\n\n  get length(): number {\n    return this.argv.length\n  }\n}\n\nclass ArgumentParser {\n  public readonly args: ParsedArguments = []\n  public readonly ddash: ParsedArguments = []\n  public readonly rawArgv: string[]\n  public readonly line: string\n  private variadicId?: number\n  private key: \"args\" | \"ddash\" = \"args\"\n\n  constructor(private config: ParserOptions, argv: string[]) {\n    this.line = argv.join(\" \")\n    this.rawArgv = argv\n  }\n\n  toJSON(): {\n    args: ParsedArguments\n    ddash: ParsedArguments\n    rawArgv: string[]\n    line: string\n  } {\n    return {\n      args: this.args,\n      ddash: this.ddash,\n      rawArgv: this.rawArgv,\n      line: this.line,\n    }\n  }\n\n  inVariadicContext(): boolean | undefined {\n    const argsLen = this[this.key].length\n    if (this.config.variadic.includes(argsLen)) {\n      this.variadicId = argsLen\n    }\n    if (this.variadicId !== undefined) {\n      return true\n    }\n  }\n\n  markDdashHandled(tree: Tree): true {\n    if (this.config.ddash) {\n      // if ddash enabled, update the key\n      this.key = \"ddash\"\n    }\n    return tree.markDdashHandled().forward()\n  }\n\n  push(...values: string[]): true {\n    this[this.key].push(...values.map(this.config.autoCast ? autoCast : String))\n    return true\n  }\n\n  pushVariadic(tree: Tree): true {\n    const args = tree.sliceFromHere()\n    const until = getNextOptPosition(args)\n    this.variadicId = this.variadicId || 0\n    const variadic = (this[this.key][this.variadicId] =\n      (this[this.key][this.variadicId] as ParserTypes[]) || [])\n\n    variadic.push(\n      ...args\n        .slice(0, until === -1 ? undefined : until)\n        .filter((s: string) => !isDdash(s))\n        .map(this.config.autoCast ? autoCast : String),\n    )\n\n    return tree.forward(until)\n  }\n\n  visit(tree: Tree): unknown {\n    if (!tree.current || (isOptionStr(tree.current) && !tree.hasDdashHandled())) {\n      return false\n    }\n    if (isDdash(tree.current)) {\n      return this.markDdashHandled(tree)\n    } else if (!this.inVariadicContext()) {\n      this.push(tree.current)\n      return tree.forward()\n    }\n    return this.pushVariadic(tree)\n  }\n}\n\nclass OptionParser {\n  public readonly options: ParsedOptions = {}\n  public readonly rawOptions: ParsedOptions = {}\n\n  constructor(private config: ParserOptions) {}\n\n  toJSON(): {\n    options: ParsedOptions\n    rawOptions: ParsedOptions\n  } {\n    return {\n      options: this.options,\n      rawOptions: this.rawOptions,\n    }\n  }\n\n  handleOptWithoutValue(name: string, tree: Tree): void {\n    const next = tree.next()\n    const nextIsOptOrUndef = isOptionStr(next) || isDdash(next) || next === undefined\n    this.compute(\n      name,\n      cast(name, nextIsOptOrUndef ? true : (next as string), this.config),\n    )\n    if (!nextIsOptOrUndef) {\n      tree.forward()\n    }\n  }\n\n  handleConcatenatedOpts(tree: Tree, names: string[], val?: ParserTypes): void {\n    if (val === undefined) {\n      val = true\n      const next = tree.next()\n      const last = names[names.length - 1]\n      const alias = this.config.alias[last]\n      const shouldTakeNextAsVal =\n        next && !isOptionStr(next) && !isDdash(next) && !this.isBoolean(last, alias)\n      if (shouldTakeNextAsVal) {\n        tree.forward()\n        val = next as string\n      }\n    }\n    this.computeMulti(names, val)\n  }\n\n  visit(tree: Tree): boolean {\n    // only handle options\n    /* istanbul ignore if */\n    if (!tree.current || !isOptionStr(tree.current) || tree.hasDdashHandled()) {\n      // this is never reached because the scan stops if\n      // a visior returns true, and as the Argument visitor is the first in the\n      // list, arguments objects never reach the Options visitor\n      // keeping it here in case we change the order of visitors\n      return false\n    }\n\n    const [name, rawval] = tree.current.split(\"=\", 2)\n    const concatOpts = isConcatenatedOpt(name)\n\n    if (concatOpts) {\n      this.handleConcatenatedOpts(tree, concatOpts, rawval)\n    } else if (rawval) {\n      this.compute(name, cast(name, rawval, this.config))\n    } else {\n      this.handleOptWithoutValue(name, tree)\n    }\n\n    return tree.forward()\n  }\n\n  compute(name: string, val: ParserTypes): void {\n    const no = isNegativeOpt(name)\n    const cleanName = formatOptName(name)\n    const alias = this.config.alias[cleanName]\n\n    if (this.isVariadic(cleanName, alias)) {\n      const prop = this.options[cleanName]\n      this.rawOptions[name] = this.options[cleanName] = (isOptArray(prop)\n        ? prop\n        : [prop]\n      ).concat(val)\n    } else {\n      this.rawOptions[name] = this.options[cleanName] = no ? !val : val\n    }\n    if (alias) {\n      this.options[alias] = this.options[cleanName]\n    }\n  }\n\n  // todo: handle variadic, even for compute multi\n  // TIP: (maybe just split and redirect the last char to compute())\n  computeMulti(multi: string[], val: ParserTypes): void {\n    const n = multi.length\n    multi.forEach((o, index) => {\n      const alias = this.config.alias[o]\n      this.options[o] = index + 1 === n ? cast(o, val as string, this.config) : true\n      this.rawOptions[\"-\" + o] = this.options[o]\n      if (alias) {\n        this.options[alias] = this.options[o]\n      }\n    })\n  }\n\n  isVariadic(name: string, alias: string): boolean {\n    return (\n      name in this.options &&\n      (this.config.variadic.includes(name) || this.config.variadic.includes(alias))\n    )\n  }\n\n  isBoolean(name: string, alias: string): boolean {\n    return this.config.boolean.includes(name) || this.config.boolean.includes(alias)\n  }\n}\n\n/**\n * Parse command line arguments\n *\n * @param options Parser options\n * @param argv command line arguments array (a.k.a. \"argv\")\n */\nexport function parseArgv(\n  options: Partial<ParserOptions> = {},\n  argv: string[] = process.argv.slice(2),\n): ParserResult {\n  const parseOpts: ParserOptions = {\n    autoCast: true,\n    ddash: false,\n    alias: {},\n    boolean: [],\n    string: [],\n    variadic: [],\n    ...options,\n  }\n  parseOpts.alias = { ...parseOpts.alias, ...invert(parseOpts.alias) }\n\n  const tree = new Tree(argv)\n  const flagParser = new OptionParser(parseOpts)\n  const argParser = new ArgumentParser(parseOpts, argv)\n  const visitors = [argParser, flagParser]\n\n  while (tree.current) {\n    visitors.some((v) => v.visit(tree))\n  }\n\n  return { ...flagParser.toJSON(), ...argParser.toJSON() }\n}\n","/* eslint-disable @typescript-eslint/ban-ts-ignore */\n/* eslint-disable @typescript-eslint/camelcase */\n/**\n * @packageDocumentation\n * @internal\n */\nimport { CommandCreator } from \"../types\"\nimport path from \"path\"\n\nconst requireFunc =\n  // @ts-ignore\n  typeof __webpack_require__ === \"function\" ? __non_webpack_require__ : require\n\nexport async function importCommand(file: string): Promise<CommandCreator> {\n  const { dir, name } = path.parse(file)\n  const filename = path.join(dir, name)\n  const mod = requireFunc(filename)\n  return mod.default ?? mod\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { Program } from \"../program\"\nimport type { Command } from \".\"\nimport { importCommand } from \"./import\"\nimport { createCommand } from \".\"\nimport path from \"path\"\n\nexport async function findCommand(\n  program: Program,\n  argv: string[],\n): Promise<Command | undefined> {\n  const commands = program.getCommands()\n  const findRegisteredCommand = (search: string): Command | undefined =>\n    commands.find((c) => c.name === search || c.hasAlias(search))\n\n  let foundCommand\n  let i\n  for (i = 0; i < argv.length; i++) {\n    const cmd = argv.slice(0, i + 1).join(\" \")\n    // break as soon as possible\n    if (argv[i].startsWith(\"-\")) {\n      break\n    }\n    const potentialCmd =\n      findRegisteredCommand(cmd) || (await discoverCommand(program, cmd))\n    foundCommand = potentialCmd || foundCommand\n  }\n\n  return foundCommand\n}\n\n/**\n * Search for a command in discovery path\n */\nasync function discoverCommand(\n  program: Program,\n  cmd: string,\n): Promise<Command | undefined> {\n  if (program.discoveryPath === undefined) {\n    return\n  }\n  const filename = cmd.split(\" \").join(\"/\")\n  try {\n    const fullPath = path.join(program.discoveryPath, filename)\n    const cmdBuilder = await importCommand(fullPath)\n    const options = {\n      createCommand: createCommand.bind(null, program, cmd),\n      program,\n    }\n    return cmdBuilder(options)\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n}\n","/**\n * @packageDocumentation\n * @module caporal/autocomplete\n */\nimport tabtab from \"tabtab\"\nimport { parseArgv } from \"../parser\"\nimport { Program } from \"../program\"\nimport { removeCommandFromArgs } from \"../argument/validate\"\nimport { Argument, Option } from \"../types\"\nimport { Command } from \"../command\"\nimport { isOptionObject } from \"../option\"\nimport { findCommand } from \"../command/find\"\nimport filter from \"lodash/filter\"\nimport flatMap from \"lodash/flatMap\"\n\nimport { Completions, Completer, CompletionItem, CompletionContext } from \"./types\"\n\nconst completions: Completions = new Map()\n\n/**\n * Register a completion handler\n *\n * @param {Argument|Option} arg_or_opt argument or option to complete\n * @param {Function} completer\n */\nexport function registerCompletion(\n  argOrOpt: Argument | Option,\n  completer: Completer,\n): void {\n  completions.set(argOrOpt, completer)\n}\n\nexport async function installCompletion(program: Program): Promise<void> {\n  return tabtab.install({\n    name: program.getBin(),\n    completer: program.getBin(),\n  })\n}\n\nexport async function uninstallCompletion(program: Program): Promise<void> {\n  return tabtab.uninstall({\n    name: program.getBin(),\n  })\n}\n\n/**\n * Called by tabtab\n */\nexport async function complete(\n  program: Program,\n  { env, argv } = { env: process.env, argv: process.argv },\n): Promise<CompletionItem[] | false> {\n  const compEnv = tabtab.parseEnv(env)\n  if (!compEnv.complete) {\n    return false\n  }\n\n  const ctx = await getContext(program, compEnv, argv)\n  const compPromises = [\n    getCompCommands(ctx),\n    getCompArgValues(ctx),\n    getCompOptNames(ctx),\n    getCompOptValues(ctx),\n  ]\n\n  const comps = flatMap(await Promise.all(compPromises))\n  tabtab.log(comps)\n\n  return comps\n}\n\nasync function getContext(\n  program: Program,\n  compEnv: tabtab.TabtabEnv,\n  argv: string[],\n): Promise<CompletionContext> {\n  const { lastPartial } = compEnv\n  argv = argv.slice(4)\n  const currentCmd = await findCommand(program, argv)\n  const parserResult = parseArgv(currentCmd?.getParserConfig(), argv)\n  const lastPartIsOpt = lastPartial.startsWith(\"-\")\n  const lastPartIsKnownOpt = Boolean(\n    lastPartIsOpt && currentCmd && getLastPartIsKnownOpt(currentCmd, lastPartial),\n  )\n  const currentOpt = currentCmd\n    ? currentCmd.options.find((o) => o.allNames.includes(lastPartial))\n    : undefined\n\n  const ctx = {\n    program,\n    currentCmd,\n    compEnv,\n    parserResult,\n    lastPartIsOpt,\n    lastPartIsKnownOpt,\n    currentOpt,\n  }\n  return ctx\n}\n\nasync function getCompCommands(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { line },\n    program,\n    currentCmd,\n  } = ctx\n  const commandMatch = (cmd: Command, str: string): boolean => {\n    return cmd.name.startsWith(str) || cmd.getAliases().some((a) => a.startsWith(str))\n  }\n  let commands = await program.getAllCommands()\n  commands = filter(commands, (cmd) => commandMatch(cmd, line) && cmd !== currentCmd)\n  return commands.map((cmd) => ({\n    name: cmd.name,\n    description: cmd.description,\n  }))\n}\n\nasync function getCompOptNames(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { lastPartial },\n    currentCmd,\n  } = ctx\n\n  if (!currentCmd) {\n    return []\n  }\n\n  const matchOptionName = (o: Option): boolean => {\n    return Boolean(\n      (o.shortNotation != lastPartial && o.shortNotation?.startsWith(lastPartial)) ||\n        (o.longNotation != lastPartial && o.longNotation?.startsWith(lastPartial)),\n    )\n  }\n\n  return filter(currentCmd.options, matchOptionName).map((opt) => ({\n    name: opt.notation,\n    description: opt.description,\n  }))\n}\n\nasync function getCompOptValues(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const { currentOpt } = ctx\n  if (!currentOpt) {\n    return []\n  }\n  // Choices\n  if (currentOpt.choices.length) {\n    return currentOpt.choices.map((choice) => ({\n      name: choice.toString(),\n      description: \"Value for option \" + currentOpt.synopsis,\n    }))\n  }\n\n  // Promise completion\n  const completer = completions.get(currentOpt)\n  if (completer) {\n    return hanldleCompleter(ctx, completer, currentOpt)\n  }\n\n  return []\n}\n\nasync function getCompArgValues(ctx: CompletionContext): Promise<CompletionItem[]> {\n  const {\n    compEnv: { lastPartial },\n    parserResult: { args },\n    currentCmd,\n    lastPartIsOpt,\n  } = ctx\n\n  if (!currentCmd || lastPartIsOpt) {\n    return []\n  }\n\n  const formatedArgs = currentCmd.isProgramCommand()\n    ? args\n    : removeCommandFromArgs(currentCmd, args)\n\n  const argsCount = formatedArgs.length\n  const arg = currentCmd.args[argsCount]\n\n  if (!arg) {\n    return []\n  }\n\n  // Choices\n  if (arg.choices.length) {\n    return arg.choices\n      .map((choice) => ({\n        name: choice.toString(),\n        description: \"Value for argument \" + arg.synopsis,\n      }))\n      .filter((choice) => !lastPartial || choice.name.toString().startsWith(lastPartial))\n  }\n\n  // Promise completion\n  const completion = completions.get(arg)\n  if (completion) {\n    return hanldleCompleter(ctx, completion, arg)\n  }\n\n  return []\n}\n\nasync function hanldleCompleter(\n  ctx: CompletionContext,\n  completer: Completer,\n  argOrOpt: Argument | Option,\n): Promise<CompletionItem[]> {\n  const type = isOptionObject(argOrOpt) ? \"option\" : \"argument\"\n  const res = await completer(ctx)\n  return res.map((item) => {\n    if (typeof item === \"object\") {\n      return item\n    }\n    return {\n      name: \"\" + item,\n      description: `Value for ${type} ${argOrOpt.synopsis}`,\n    }\n  })\n}\n\nfunction getLastPartIsKnownOpt(cmd: Command, lastPartial: string): boolean {\n  return cmd.options.some((o) => o.allNames.includes(lastPartial))\n}\n","/**\n * @packageDocumentation\n * @module caporal/option\n */\n\nimport {\n  Option,\n  OptionValueType,\n  CreateOptionProgramOpts,\n  CreateOptionCommandOpts,\n  Action,\n  ActionParameters,\n  GlobalOptions,\n  ParserProcessedResult,\n} from \"../types\"\nimport { checkValidator, isBoolValidator, getTypeHint } from \"../validator/utils\"\nimport { parseOptionSynopsis } from \"./utils\"\nimport { logger } from \"../logger\"\nimport type { Command } from \"../command\"\nimport type { Program } from \"../program\"\nimport { getHelp } from \"../help\"\nimport { installCompletion, uninstallCompletion } from \"../autocomplete\"\n\n/**\n * Create an Option object\n *\n * @internal\n * @param synopsis\n * @param description\n * @param options\n */\nexport function createOption(\n  synopsis: string,\n  description: string,\n  options: CreateOptionProgramOpts | CreateOptionCommandOpts = {},\n): Option {\n  // eslint-disable-next-line prefer-const\n  let { validator, required, hidden } = options\n\n  // force casting\n  required = Boolean(required)\n\n  checkValidator(validator)\n  const syno = parseOptionSynopsis(synopsis)\n  let boolean = syno.valueType === OptionValueType.None || isBoolValidator(validator)\n  if (validator && !isBoolValidator(validator)) {\n    boolean = false\n  }\n\n  const opt: Option = {\n    kind: \"option\",\n    default: boolean == true ? Boolean(options.default) : options.default,\n    description,\n    choices: Array.isArray(validator) ? validator : [],\n    ...syno,\n    required,\n    visible: !hidden,\n    boolean,\n    validator,\n  }\n\n  opt.typeHint = getTypeHint(opt)\n\n  return opt\n}\n\nexport { showHelp }\n\n/**\n * Display help. Return false to prevent further processing.\n *\n * @internal\n */\nconst showHelp: Action = async ({ program, command }: ActionParameters) => {\n    const help = await getHelp(program, command)\n    // eslint-disable-next-line no-console\n    console.log(help)\n    program.emit(\"help\", help)\n    return false\n  },\n  /**\n   * Display program version. Return false to prevent further processing.\n   *\n   * @internal\n   */\n  showVersion: Action = ({ program }: ActionParameters) => {\n    // eslint-disable-next-line no-console\n    console.log(program.getVersion())\n    program.emit(\"version\", program.getVersion())\n    return false\n  },\n  /**\n   * Disable colors in output\n   *\n   * @internal\n   */\n  disableColors: Action = ({ logger }: ActionParameters) => {\n    logger.disableColors()\n  },\n  /**\n   * Set verbosity to the maximum\n   *\n   * @internal\n   */\n  setVerbose: Action = ({ logger }: ActionParameters) => {\n    logger.level = \"silly\"\n  },\n  /**\n   * Makes the program quiet, eg displaying logs with level >= warning\n   */\n  setQuiet: Action = ({ logger }: ActionParameters) => {\n    logger.level = \"warn\"\n  },\n  /**\n   * Makes the program totally silent\n   */\n  setSilent: Action = ({ logger }: ActionParameters) => {\n    logger.silent = true\n  },\n  /**\n   * Install completion\n   */\n  installComp: Action = ({ program }: ActionParameters) => {\n    return installCompletion(program)\n  },\n  /**\n   * Uninstall completion\n   */\n  uninstallComp: Action = ({ program }: ActionParameters) => {\n    return uninstallCompletion(program)\n  }\n\n/**\n * Global options container\n *\n * @internal\n */\nlet globalOptions: undefined | GlobalOptions\n\n/**\n * Get the list of registered global flags\n *\n * @internal\n */\nexport function getGlobalOptions(): GlobalOptions {\n  if (globalOptions === undefined) {\n    globalOptions = setupGlobalOptions()\n  }\n  return globalOptions\n}\n\n/**\n * Set up the global flags\n *\n * @internal\n */\nfunction setupGlobalOptions(): GlobalOptions {\n  const help = createOption(\"-h, --help\", \"Display global help or command-related help.\"),\n    verbose = createOption(\n      \"-v, --verbose\",\n      \"Verbose mode: will also output debug messages.\",\n    ),\n    quiet = createOption(\n      \"--quiet\",\n      \"Quiet mode - only displays warn and error messages.\",\n    ),\n    silent = createOption(\n      \"--silent\",\n      \"Silent mode: does not output anything, giving no indication of success or failure other than the exit code.\",\n    ),\n    version = createOption(\"-V, --version\", \"Display version.\"),\n    color = createOption(\"--no-color\", \"Disable use of colors in output.\"),\n    installCompOpt = createOption(\n      \"--install-completion\",\n      \"Install completion for your shell.\",\n      { hidden: true },\n    ),\n    uninstallCompOpt = createOption(\n      \"--uninstall-completion\",\n      \"Uninstall completion for your shell.\",\n      { hidden: true },\n    )\n\n  return new Map([\n    [help, showHelp],\n    [version, showVersion],\n    [color, disableColors],\n    [verbose, setVerbose],\n    [quiet, setQuiet],\n    [silent, setSilent],\n    [installCompOpt, installComp],\n    [uninstallCompOpt, uninstallComp],\n  ])\n}\n\nexport function resetGlobalOptions(): GlobalOptions {\n  return (globalOptions = setupGlobalOptions())\n}\n\n/**\n * Disable a global option\n *\n * @param name Can be the option short/long name or notation\n */\nexport function disableGlobalOption(name: string): boolean {\n  const opts = getGlobalOptions()\n  for (const [opt] of opts) {\n    if (opt.allNames.includes(name) || opt.allNotations.includes(name)) {\n      return opts.delete(opt)\n    }\n  }\n  return false\n}\n\n/**\n * Add a global option to the program.\n * A global option is available at the program level,\n * and associated with one given {@link Action}.\n *\n * @param a {@link Option} instance, for example created using {@link createOption()}\n */\nexport function addGlobalOption(opt: Option, action?: Action): GlobalOptions {\n  return getGlobalOptions().set(opt, action)\n}\n\n/**\n * Process global options, if any\n * @internal\n */\nexport async function processGlobalOptions(\n  parsed: ParserProcessedResult,\n  program: Program,\n  command?: Command,\n): Promise<boolean> {\n  const { options } = parsed\n  const actionsParams = { ...parsed, logger, program, command }\n  const promises = Object.entries(options).map(([opt]) => {\n    const action = findGlobalOptAction(opt)\n    if (action) {\n      return action(actionsParams)\n    }\n  })\n  const results = await Promise.all(promises)\n  return results.some((r) => r === false)\n}\n\n/**\n * Find a global Option action from the option name (short or long)\n *\n * @param name Short or long name\n * @internal\n */\nexport function findGlobalOptAction(name: string): Action | undefined {\n  for (const [opt, action] of getGlobalOptions()) {\n    if (opt.allNames.includes(name)) {\n      return action\n    }\n  }\n}\n\n/**\n * Find a global Option by it's name (short or long)\n *\n * @param name Short or long name\n * @internal\n */\nexport function findGlobalOption(name: string): Option | undefined {\n  for (const [opt] of getGlobalOptions()) {\n    if (opt.allNames.includes(name)) {\n      return opt\n    }\n  }\n}\n\nexport function isOptionObject(obj: unknown): obj is Option {\n  return typeof obj == \"object\" && obj !== null && (obj as Option).kind == \"option\"\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nexport function levenshtein(a: string, b: string): number {\n  if (a === b) {\n    return 0\n  }\n  if (!a.length || !b.length) {\n    return a.length || b.length\n  }\n  let cell = 0\n  let lcell = 0\n  let dcell = 0\n  const row = [...Array(b.length + 1).keys()]\n  for (let i = 0; i < a.length; i++) {\n    dcell = i\n    lcell = i + 1\n    for (let j = 0; j < b.length; j++) {\n      cell = a[i] === b[j] ? dcell : Math.min(...[dcell, row[j + 1], lcell]) + 1\n      dcell = row[j + 1]\n      row[j] = lcell\n      lcell = cell\n    }\n    row[row.length - 1] = cell\n  }\n  return cell\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport chalk from \"chalk\"\nimport { levenshtein } from \"./levenshtein\"\n\ninterface Suggestion {\n  distance: number\n  suggestion: string\n}\n\nconst MAX_DISTANCE = 2\n\nconst sortByDistance = (a: Suggestion, b: Suggestion): number => a.distance - b.distance\n\nconst keepMeaningfulSuggestions = (s: Suggestion): boolean => s.distance <= MAX_DISTANCE\n\nconst possibilitesMapper = (input: string, p: string): Suggestion => {\n  return { suggestion: p, distance: levenshtein(input, p) }\n}\n\n/**\n * Get autocomplete suggestions\n *\n * @param {String} input - User input\n * @param {String[]} possibilities - Possibilities to retrieve suggestions from\n */\nexport function getSuggestions(input: string, possibilities: string[]): string[] {\n  return possibilities\n    .map((p) => possibilitesMapper(input, p))\n    .filter(keepMeaningfulSuggestions)\n    .sort(sortByDistance)\n    .map((p) => p.suggestion)\n}\n\n/**\n * Make diff bolder in a string\n *\n * @param from original string\n * @param to target string\n */\nexport function boldDiffString(from: string, to: string): string {\n  return [...to]\n    .map((char, index) => {\n      if (char != from.charAt(index)) {\n        return chalk.bold.greenBright(char)\n      }\n      return char\n    })\n    .join(\"\")\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport type { Option } from \"../types\"\nimport { getDashedOpt } from \"../option/utils\"\nimport { getGlobalOptions } from \"../option\"\nimport { getSuggestions, boldDiffString } from \"../utils/suggest\"\nimport c from \"chalk\"\nimport type { Command } from \"../command\"\nimport filter from \"lodash/fp/filter\"\nimport map from \"lodash/fp/map\"\n\n/**\n * @todo Rewrite\n */\nexport class UnknownOptionError extends BaseError {\n  constructor(flag: string, command: Command) {\n    const longFlags = filter((f: Option) => f.name.length > 1),\n      getFlagNames = map((f: Option) => f.name),\n      possibilities = getFlagNames([\n        ...longFlags(command.options),\n        ...getGlobalOptions().keys(),\n      ]),\n      suggestions = getSuggestions(flag, possibilities)\n\n    let msg = `Unknown option ${c.bold.redBright(getDashedOpt(flag))}. `\n    if (suggestions.length) {\n      msg +=\n        \"Did you mean \" +\n        suggestions\n          .map((s) => boldDiffString(getDashedOpt(flag), getDashedOpt(s)))\n          .join(\" or maybe \") +\n        \" ?\"\n    }\n    super(msg, { flag, command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { getSuggestions, boldDiffString } from \"../utils/suggest\"\nimport chalk from \"chalk\"\nimport type { Program } from \"../program\"\nimport flatMap from \"lodash/flatMap\"\nimport filter from \"lodash/filter\"\nimport wrap from \"wrap-ansi\"\n\n/**\n * @todo Rewrite\n */\nexport class UnknownOrUnspecifiedCommandError extends BaseError {\n  constructor(program: Program, command?: string) {\n    const possibilities = filter(\n      flatMap(program.getCommands(), (c) => [c.name, ...c.getAliases()]),\n    )\n    let msg = \"\"\n    if (command) {\n      msg = `Unknown command ${chalk.bold(command)}.`\n      const suggestions = getSuggestions(command, possibilities)\n      if (suggestions.length) {\n        msg +=\n          \" Did you mean \" +\n          suggestions.map((s) => boldDiffString(command, s)).join(\" or maybe \") +\n          \" ?\"\n      }\n    } else {\n      msg =\n        \"Unspecified command. Available commands are:\\n\" +\n        wrap(possibilities.map((p) => chalk.whiteBright(p)).join(\", \"), 60) +\n        \".\" +\n        `\\n\\nFor more help, type ${chalk.whiteBright(program.getBin() + \" --help\")}`\n    }\n\n    super(msg, { command })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { format } from \"util\"\nimport c from \"chalk\"\nimport { BaseError } from \"./base\"\nimport { Validator, ParserTypes, Argument, Option, CaporalValidator } from \"../types\"\nimport { isCaporalValidator } from \"../validator/utils\"\n\ninterface ValidationErrorParameters {\n  value: ParserTypes | ParserTypes[]\n  error?: Error | string\n  validator: Validator\n  context: Argument | Option\n}\n\nfunction isOptionObject(obj: Option | Argument): obj is Option {\n  return \"allNotations\" in obj\n}\n\nexport class ValidationError extends BaseError {\n  constructor({ value, error, validator, context }: ValidationErrorParameters) {\n    let message = error instanceof Error ? error.message : error\n    const varName = isOptionObject(context) ? \"option\" : \"argument\"\n    const name = isOptionObject(context)\n      ? context.allNotations.join(\"|\")\n      : context.synopsis\n\n    if (isCaporalValidator(validator)) {\n      switch (validator) {\n        case CaporalValidator.NUMBER:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"number\"),\n            c.redBright(value),\n          )\n          break\n        case CaporalValidator.BOOLEAN:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s (true, false, 0, 1), but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"boolean\"),\n            c.redBright(value),\n          )\n          break\n        case CaporalValidator.STRING:\n          message = format(\n            'Invalid value for %s %s.\\nExpected a %s, but got \"%s\".',\n            varName,\n            c.redBright(name),\n            c.underline(\"string\"),\n            c.redBright(value),\n          )\n          break\n      }\n    } else if (Array.isArray(validator)) {\n      message = format(\n        'Invalid value for %s %s.\\nExpected one of %s, but got \"%s\".',\n        varName,\n        c.redBright(name),\n        \"'\" + validator.join(\"', '\") + \"'\",\n        c.redBright(value),\n      )\n    } else if (validator instanceof RegExp) {\n      message = format(\n        'Invalid value for %s %s.\\nExpected a value matching %s, but got \"%s\".',\n        varName,\n        c.redBright(name),\n        c.whiteBright(validator.toString()),\n        c.redBright(value),\n      )\n    }\n    super(message + \"\")\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport { BaseError } from \"./base\"\nimport { ArgumentsRange } from \"../types\"\nimport { Command } from \"../command\"\nimport { format } from \"util\"\nimport c from \"chalk\"\n\nexport class TooManyArgumentsError extends BaseError {\n  constructor(cmd: Command, range: ArgumentsRange, argsCount: number) {\n    const expArgsStr =\n      range.min === range.max\n        ? `exactly ${range.min}.`\n        : `between ${range.min} and ${range.max}.`\n\n    const cmdName = cmd.isProgramCommand() ? \"\" : `for command ${c.bold(cmd.name)}`\n    const message = format(\n      `Too many argument(s) %s. Got %s, expected %s`,\n      cmdName,\n      c.bold.redBright(argsCount),\n      c.bold.greenBright(expArgsStr),\n    )\n    super(message, { command: cmd })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { CaporalValidator } from \"../types\"\nimport { ValidationError } from \"../error\"\nimport { isNumeric } from \"../option/utils\"\nimport flatMap from \"lodash/flatMap\"\n\nimport {\n  isNumericValidator,\n  isStringValidator,\n  isBoolValidator,\n  isArrayValidator,\n} from \"./utils\"\n\n// Re-export for convenience\nexport { CaporalValidator }\n\nexport function validateWithCaporal(\n  validator: CaporalValidator,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n  skipArrayValidation = false,\n): ParserTypes | ParserTypes[] {\n  if (!skipArrayValidation && isArrayValidator(validator)) {\n    return validateArrayFlag(validator, value, context)\n  } else if (Array.isArray(value)) {\n    // should not happen!\n    throw new ValidationError({\n      error: \"Expected a scalar value, got an array\",\n      value,\n      validator,\n      context,\n    })\n  } else if (isNumericValidator(validator)) {\n    return validateNumericFlag(validator, value, context)\n  } else if (isStringValidator(validator)) {\n    return validateStringFlag(value)\n  } else if (isBoolValidator(validator)) {\n    return validateBoolFlag(value, context)\n  }\n  return value\n}\n\n/**\n * The string validator actually just cast the value to string\n *\n * @param value\n * @ignore\n */\nexport function validateBoolFlag(\n  value: ParserTypes,\n  context: Argument | Option,\n): boolean {\n  if (typeof value === \"boolean\") {\n    return value\n  } else if (/^(true|false|yes|no|0|1)$/i.test(String(value)) === false) {\n    throw new ValidationError({\n      value,\n      validator: CaporalValidator.BOOLEAN,\n      context,\n    })\n  }\n  return /^0|no|false$/.test(String(value)) === false\n}\n\nexport function validateNumericFlag(\n  validator: number,\n  value: ParserTypes,\n  context: Argument | Option,\n): number {\n  const str = value + \"\"\n  if (Array.isArray(value) || !isNumeric(str)) {\n    throw new ValidationError({\n      value,\n      validator,\n      context,\n    })\n  }\n  return parseFloat(str)\n}\n\nexport function validateArrayFlag(\n  validator: number,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  const values: ParserTypes[] =\n    typeof value === \"string\" ? value.split(\",\") : !Array.isArray(value) ? [value] : value\n  return flatMap(values, (el) => validateWithCaporal(validator, el, context, true))\n}\n\n/**\n * The string validator actually just cast the value to string\n *\n * @param value\n * @ignore\n */\nexport function validateStringFlag(value: ParserTypes | ParserTypes[]): string {\n  return value + \"\"\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type {\n  Validator,\n  Promisable,\n  ParsedOption,\n  ParsedArgument,\n  Argument,\n  Option,\n} from \"../types\"\n\nimport { validateWithRegExp } from \"./regexp\"\nimport { validateWithArray } from \"./array\"\nimport { validateWithFunction } from \"./function\"\nimport { validateWithCaporal } from \"./caporal\"\nimport { isCaporalValidator } from \"./utils\"\n\nexport function validate(\n  value: ParsedOption | ParsedArgument,\n  validator: Validator,\n  context: Argument | Option,\n): Promisable<ParsedOption | ParsedArgument> {\n  if (typeof validator === \"function\") {\n    return validateWithFunction(validator, value, context)\n  } else if (validator instanceof RegExp) {\n    return validateWithRegExp(validator, value, context)\n  } else if (Array.isArray(validator)) {\n    return validateWithArray(validator, value, context)\n  }\n  // Caporal flag validator\n  else if (isCaporalValidator(validator)) {\n    return validateWithCaporal(validator, value, context)\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, FunctionValidator, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\nexport async function validateWithFunction(\n  validator: FunctionValidator,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): Promise<ParserTypes | ParserTypes[]> {\n  if (Array.isArray(value)) {\n    return Promise.all(\n      value.map((v) => {\n        return validateWithFunction(validator, v, context) as Promise<ParserTypes>\n      }),\n    )\n  }\n  try {\n    return await validator(value)\n  } catch (error) {\n    throw new ValidationError({\n      validator,\n      value,\n      error,\n      context,\n    })\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\n/**\n * Validate using a RegExp\n *\n * @param validator\n * @param value\n * @ignore\n */\nexport function validateWithRegExp(\n  validator: RegExp,\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  if (Array.isArray(value)) {\n    return value.map((v) => {\n      return validateWithRegExp(validator, v, context) as ParserTypes\n    })\n  }\n  if (!validator.test(value + \"\")) {\n    throw new ValidationError({\n      validator: validator,\n      value,\n      context,\n    })\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { ParserTypes, Argument, Option } from \"../types\"\nimport { ValidationError } from \"../error\"\n\n/**\n * Validate using an array of valid values.\n *\n * @param validator\n * @param value\n * @ignore\n */\nexport function validateWithArray(\n  validator: ParserTypes[],\n  value: ParserTypes | ParserTypes[],\n  context: Argument | Option,\n): ParserTypes | ParserTypes[] {\n  if (Array.isArray(value)) {\n    value.forEach((v) => validateWithArray(validator, v, context))\n  } else if (validator.includes(value) === false) {\n    throw new ValidationError({\n      validator,\n      value,\n      context,\n    })\n  }\n  return value\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport reduce from \"lodash/reduce\"\nimport { TooManyArgumentsError, MissingArgumentError, BaseError } from \"../error\"\nimport type {\n  Argument,\n  ArgumentsRange,\n  ParsedArguments,\n  ParsedArgumentsObject,\n  ParsedArgument,\n  Promisable,\n} from \"../types\"\n\nimport type { Command } from \"../command\"\nimport { validate } from \"../validator/validate\"\nimport { findArgument } from \"./find\"\n\n/**\n * Get the number of required argument for a given command\n *\n * @param cmd\n */\nexport function getRequiredArgsCount(cmd: Command): number {\n  return cmd.args.filter((a) => a.required).length\n}\n\nexport function getArgsObjectFromArray(\n  cmd: Command,\n  args: ParsedArguments,\n): ParsedArgumentsObject {\n  const result: ParsedArgumentsObject = {}\n  return cmd.args.reduce((acc, arg, index) => {\n    if (args[index] !== undefined) {\n      acc[arg.name] = args[index]\n    } else if (arg.default !== undefined) {\n      acc[arg.name] = arg.default\n    }\n    return acc\n  }, result)\n}\n\n/**\n * Check if the given command has at leat one variadic argument\n *\n * @param cmd\n */\nexport function hasVariadicArgument(cmd: Command): boolean {\n  return cmd.args.some((a) => a.variadic)\n}\n\nexport function getArgsRange(cmd: Command): ArgumentsRange {\n  const min = getRequiredArgsCount(cmd)\n  const max = hasVariadicArgument(cmd) ? Infinity : cmd.args.length\n  return { min, max }\n}\n\nexport function checkRequiredArgs(\n  cmd: Command,\n  args: ParsedArgumentsObject,\n  parsedArgv: ParsedArguments,\n): BaseError[] {\n  const errors = cmd.args.reduce((acc, arg) => {\n    if (args[arg.name] === undefined && arg.required) {\n      acc.push(new MissingArgumentError(arg, cmd))\n    }\n    return acc\n  }, [] as BaseError[])\n\n  // Check if there is more args than specified\n  if (cmd.strictArgsCount) {\n    const numArgsError = checkNumberOfArgs(cmd, parsedArgv)\n    if (numArgsError) {\n      errors.push(numArgsError)\n    }\n  }\n\n  return errors\n}\n\nfunction checkNumberOfArgs(\n  cmd: Command,\n  args: ParsedArguments,\n): TooManyArgumentsError | void {\n  const range = getArgsRange(cmd)\n  const argsCount = Object.keys(args).length\n  if (range.max !== Infinity && range.max < Object.keys(args).length) {\n    return new TooManyArgumentsError(cmd, range, argsCount)\n  }\n}\n\nexport function removeCommandFromArgs(\n  cmd: Command,\n  args: ParsedArguments,\n): ParsedArguments {\n  const words = cmd.name.split(\" \").length\n  return args.slice(words)\n}\n\nfunction validateArg(arg: Argument, value: ParsedArgument): ReturnType<typeof validate> {\n  return arg.validator ? validate(value, arg.validator, arg) : value\n}\n\ntype VariadicArgument = ParsedArgument\ntype ArgsValidatorAccumulator = Record<string, Promisable<VariadicArgument>>\n\ninterface ArgsValidationResult {\n  args: ParsedArgumentsObject\n  errors: BaseError[]\n}\n\n/**\n *\n * @param cmd\n * @param parsedArgv\n *\n * @todo Bugs:\n *\n *\n * ts-node examples/pizza/pizza.ts cancel my-order jhazd hazd\n *\n * -> result ok, should be too many arguments\n *\n */\nexport async function validateArgs(\n  cmd: Command,\n  parsedArgv: ParsedArguments,\n): Promise<ArgsValidationResult> {\n  // remove the command from the argv array\n  const formatedArgs = cmd.isProgramCommand()\n    ? parsedArgv\n    : removeCommandFromArgs(cmd, parsedArgv)\n\n  // transfrom args array to object, and set defaults for arguments not passed\n  const argsObj = getArgsObjectFromArray(cmd, formatedArgs)\n  const errors: BaseError[] = []\n\n  const validations = reduce(\n    argsObj,\n    (acc, value, key) => {\n      const arg = findArgument(cmd, key)\n      try {\n        /* istanbul ignore if -- should not happen */\n        if (!arg) {\n          throw new BaseError(`Unknown argumment ${key}`)\n        }\n        acc[key] = validateArg(arg, value)\n      } catch (e) {\n        errors.push(e)\n      }\n      return acc\n    },\n    {} as ArgsValidatorAccumulator,\n  )\n\n  const result = await reduce(\n    validations,\n    async (prevPromise, value, key): Promise<ParsedArgumentsObject> => {\n      const collection = await prevPromise\n      collection[key] = await value\n      return collection\n    },\n    Promise.resolve({}) as Promise<ParsedArgumentsObject>,\n  )\n\n  errors.push(...checkRequiredArgs(cmd, result, formatedArgs))\n\n  return { args: result, errors }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Argument } from \"../types\"\nimport type { Command } from \"../command\"\n\nexport function findArgument(cmd: Command, name: string): Argument | undefined {\n  return cmd.args.find((a) => a.name === name)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport reduce from \"lodash/reduce\"\nimport { findOption } from \"./find\"\nimport { MissingFlagError, UnknownOptionError, BaseError } from \"../error\"\nimport { findGlobalOption } from \".\"\nimport { validate } from \"../validator/validate\"\n\nimport type { ParsedOption, ParsedOptions, Promisable, Option } from \"../types\"\nimport type { Command } from \"../command\"\n\nfunction validateOption(opt: Option, value: ParsedOption): ReturnType<typeof validate> {\n  return opt.validator ? validate(value, opt.validator, opt) : value\n}\n\nexport function checkRequiredOpts(cmd: Command, opts: ParsedOptions): BaseError[] {\n  return cmd.options.reduce((acc, opt) => {\n    if (opts[opt.name] === undefined && opt.required) {\n      acc.push(new MissingFlagError(opt, cmd))\n    }\n    return acc\n  }, [] as BaseError[])\n}\n\nfunction applyDefaults(cmd: Command, opts: ParsedOptions): ParsedOptions {\n  return cmd.options.reduce((acc, opt) => {\n    if (acc[opt.name] === undefined && opt.default !== undefined) {\n      acc[opt.name] = opt.default\n    }\n    return acc\n  }, opts)\n}\n\ntype OptionsPromises = Record<string, Promisable<ParsedOption>>\n\ninterface OptionsValidationResult {\n  options: ParsedOptions\n  errors: BaseError[]\n}\n\nexport async function validateOptions(\n  cmd: Command,\n  options: ParsedOptions,\n): Promise<OptionsValidationResult> {\n  options = applyDefaults(cmd, options)\n  const errors: BaseError[] = []\n  const validations = reduce(\n    options,\n    (...args) => {\n      const [acc, value, name] = args\n      const opt = findGlobalOption(name) || findOption(cmd, name)\n      try {\n        if (opt) {\n          acc[name] = validateOption(opt, value)\n        } else if (cmd.strictOptions) {\n          throw new UnknownOptionError(name, cmd)\n        }\n      } catch (e) {\n        errors.push(e)\n      }\n      return acc\n    },\n    {} as OptionsPromises,\n  )\n  const result = await reduce(\n    validations,\n    async (prevPromise, value, key): Promise<ParsedOptions> => {\n      const collection = await prevPromise\n      collection[key] = await value\n      return collection\n    },\n    Promise.resolve({}) as Promise<ParsedOptions>,\n  )\n\n  errors.push(...checkRequiredOpts(cmd, result))\n  return { options: result, errors }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Command } from \"../command\"\nimport type { Option } from \"../types\"\n\n/**\n * Find an option from its name for a given command\n *\n * @param cmd Command object\n * @param name Option name, short or long, camel-cased\n */\nexport function findOption(cmd: Command, name: string): Option | undefined {\n  return cmd.options.find((o) => o.allNames.find((opt) => opt === name))\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { Argument, CreateArgumentOpts } from \"../types\"\nimport { checkValidator, getTypeHint } from \"../validator/utils\"\nimport { parseArgumentSynopsis } from \"./synopsis\"\n\n/**\n *\n * @param synopsis - Argument synopsis\n * @param description - Argument description\n * @param [options] - Various argument options like validator and default value\n */\nexport function createArgument(\n  synopsis: string,\n  description: string,\n  options: CreateArgumentOpts = {},\n): Argument {\n  const { validator, default: defaultValue } = options\n  checkValidator(validator)\n\n  const syno = parseArgumentSynopsis(synopsis)\n  const arg: Argument = {\n    kind: \"argument\",\n    default: defaultValue,\n    description,\n    choices: Array.isArray(validator) ? validator : [],\n    validator,\n    ...syno,\n  }\n  arg.typeHint = getTypeHint(arg)\n\n  return arg\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { ArgumentSynopsis } from \"../types\"\nimport { getCleanNameFromNotation } from \"../option/utils\"\n\n/**\n * Check if the argument is explicitly required\n *\n * @ignore\n * @param synopsis\n */\nexport function isRequired(synopsis: string): boolean {\n  return synopsis.substring(0, 1) === \"<\"\n}\n\n/**\n *\n * @param synopsis\n */\nexport function isVariadic(synopsis: string): boolean {\n  return synopsis.substr(-4, 3) === \"...\" || synopsis.endsWith(\"...\")\n}\n\nexport function parseArgumentSynopsis(synopsis: string): ArgumentSynopsis {\n  synopsis = synopsis.trim()\n  const rawName = getCleanNameFromNotation(synopsis, false)\n  const name = getCleanNameFromNotation(synopsis)\n  const required = isRequired(synopsis)\n  const variadic = isVariadic(synopsis)\n  const cleanSynopsis = required\n    ? `<${rawName}${variadic ? \"...\" : \"\"}>`\n    : `[${rawName}${variadic ? \"...\" : \"\"}]`\n  return {\n    name,\n    synopsis: cleanSynopsis,\n    required,\n    variadic,\n  }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\n\nimport type { Command } from \"../command\"\nimport map from \"lodash/map\"\nimport zipObject from \"lodash/zipObject\"\nimport invert from \"lodash/invert\"\nimport pickBy from \"lodash/pickBy\"\n\nexport function getOptsMapping(cmd: Command): Record<string, string> {\n  const names = map(cmd.options, \"name\")\n  const aliases = map(cmd.options, (o) => o.shortName || o.longName)\n  const result = zipObject(names, aliases)\n  return pickBy({ ...result, ...invert(result) }) as Record<string, string>\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport type { Configurator } from \"../types\"\n\nexport function createConfigurator<T>(defaults: T): Configurator<T> {\n  const _defaults = defaults\n  let config = defaults\n  return {\n    reset(): T {\n      config = _defaults\n      return config\n    },\n    get<K extends keyof T>(key: K): T[K] {\n      return config[key]\n    },\n    getAll(): T {\n      return config\n    },\n    set(props: Partial<T>): T {\n      return Object.assign(config, props)\n    },\n  }\n}\n","/**\n * @packageDocumentation\n * @module caporal/command\n */\nimport { validateCall } from \"./validate-call\"\nimport { logger } from \"../logger\"\nimport { createArgument } from \"../argument\"\nimport { createOption, processGlobalOptions } from \"../option\"\nimport { registerCompletion } from \"../autocomplete\"\nimport { Completer } from \"../autocomplete/types\"\nimport { getOptsMapping } from \"../option/mapping\"\nimport { isStringValidator, isBoolValidator } from \"../validator/utils\"\nimport type { Program } from \"../program\"\nimport { ActionError, NoActionError, BaseError, ValidationSummaryError } from \"../error\"\nimport {\n  Action,\n  ParserOptions,\n  ParserResult,\n  Option,\n  Argument,\n  CreateArgumentOpts,\n  Configurator,\n  CommandConfig,\n  CreateOptionCommandOpts,\n} from \"../types\"\nimport { CustomizedHelpOpts } from \"../help/types\"\nimport { customizeHelp } from \"../help\"\nimport { createConfigurator } from \"../config\"\n\n/**\n * @ignore\n */\nexport const PROG_CMD = \"__self_cmd\"\n\n/**\n * @ignore\n */\nexport const HELP_CMD = \"help\"\n\n/**\n * Command class\n *\n */\nexport class Command {\n  private program: Program\n  private _action?: Action\n  private _lastAddedArgOrOpt?: Argument | Option\n  private _aliases: string[] = []\n  private _name: string\n  private _config: Configurator<CommandConfig>\n  /**\n   * Command description\n   *\n   * @internal\n   */\n  readonly description: string\n  /**\n   * Command options array\n   *\n   * @internal\n   */\n  readonly options: Option[] = []\n  /**\n   * Command arguments array\n   *\n   * @internal\n   */\n  readonly args: Argument[] = []\n\n  /**\n   *\n   * @param program\n   * @param name\n   * @param description\n   * @internal\n   */\n  constructor(\n    program: Program,\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ) {\n    this.program = program\n    this._name = name\n    this.description = description\n    this._config = createConfigurator({ visible: true, ...config })\n  }\n\n  /**\n   * Add one or more aliases so the command can be called by different names.\n   *\n   * @param aliases Command aliases\n   */\n  alias(...aliases: string[]): Command {\n    this._aliases.push(...aliases)\n    return this\n  }\n\n  /**\n   * Name getter. Will return an empty string in the program-command context\n   *\n   * @internal\n   */\n  get name(): string {\n    return this.isProgramCommand() ? \"\" : this._name\n  }\n\n  /**\n   * Add an argument to the command.\n   * Synopsis is a string like `<my-argument>` or `[my-argument]`.\n   * Angled brackets (e.g. `<item>`) indicate required input. Square brackets (e.g. `[env]`) indicate optional input.\n   *\n   * Returns the {@link Command} object to facilitate chaining of methods.\n   *\n   * @param synopsis Argument synopsis.\n   * @param description - Argument description.\n   * @param [options] - Optional parameters including validator and default value.\n   */\n  argument(\n    synopsis: string,\n    description: string,\n    options: CreateArgumentOpts = {},\n  ): Command {\n    this._lastAddedArgOrOpt = createArgument(synopsis, description, options)\n    this.args.push(this._lastAddedArgOrOpt)\n    return this\n  }\n\n  /**\n   * Set the corresponding action to execute for this command\n   *\n   * @param action Action to execute\n   */\n  action(action: Action): Command {\n    this._action = action\n    return this\n  }\n\n  /**\n   * Allow chaining command() calls. See {@link Program.command}.\n   *\n   */\n  command(\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ): Command {\n    return this.program.command(name, description, config)\n  }\n\n  /**\n   * Makes the command the default one for the program.\n   */\n  default(): Command {\n    this.program.defaultCommand = this\n    return this\n  }\n\n  /**\n   * Checks if the command has the given alias registered.\n   *\n   * @param alias\n   * @internal\n   */\n  hasAlias(alias: string): boolean {\n    return this._aliases.includes(alias)\n  }\n\n  /**\n   * Get command aliases.\n   * @internal\n   */\n  getAliases(): string[] {\n    return this._aliases\n  }\n\n  /**\n   * @internal\n   */\n  isProgramCommand(): boolean {\n    return this._name === PROG_CMD\n  }\n\n  /**\n   * @internal\n   */\n  isHelpCommand(): boolean {\n    return this._name === HELP_CMD\n  }\n\n  /**\n   * Hide the command from help.\n   * Shortcut to calling `.configure({ visible: false })`.\n   */\n  hide(): Command {\n    return this.configure({ visible: false })\n  }\n\n  /**\n   * Add an option to the current command.\n   *\n   * @param synopsis Option synopsis like '-f, --force', or '-f, --file \\<file\\>', or '--with-openssl [path]'\n   * @param description Option description\n   * @param options Additional parameters\n   */\n  option(\n    synopsis: string,\n    description: string,\n    options: CreateOptionCommandOpts = {},\n  ): Command {\n    const opt = (this._lastAddedArgOrOpt = createOption(synopsis, description, options))\n    this.options.push(opt)\n    return this\n  }\n\n  /**\n   * @internal\n   */\n  getParserConfig(): Partial<ParserOptions> {\n    const defaults: ParserOptions = {\n      boolean: [],\n      string: [],\n      alias: getOptsMapping(this),\n      autoCast: this.autoCast,\n      variadic: [],\n      ddash: false,\n    }\n    let parserOpts = this.options.reduce((parserOpts, opt) => {\n      if (opt.boolean) {\n        parserOpts.boolean.push(opt.name)\n      }\n      if (isStringValidator(opt.validator)) {\n        parserOpts.string.push(opt.name)\n      }\n      if (opt.variadic) {\n        parserOpts.variadic.push(opt.name)\n      }\n      return parserOpts\n    }, defaults)\n\n    parserOpts = this.args.reduce((parserOpts, arg, index) => {\n      if (!this.isProgramCommand()) {\n        index++\n      }\n      if (isBoolValidator(arg.validator)) {\n        parserOpts.boolean.push(index)\n      }\n      if (isStringValidator(arg.validator)) {\n        parserOpts.string.push(index)\n      }\n      if (arg.variadic) {\n        parserOpts.variadic.push(index)\n      }\n      return parserOpts\n    }, parserOpts)\n\n    return parserOpts\n  }\n\n  /**\n   * Return a reformated synopsis string\n   * @internal\n   */\n  get synopsis(): string {\n    const opts = this.options.length\n      ? this.options.some((f) => f.required)\n        ? \"<OPTIONS...>\"\n        : \"[OPTIONS...]\"\n      : \"\"\n    const name = this._name !== PROG_CMD ? \" \" + this._name : \"\"\n\n    return (\n      this.program.getBin() +\n      name +\n      \" \" +\n      this.args.map((a) => a.synopsis).join(\" \") +\n      \" \" +\n      opts\n    ).trim()\n  }\n\n  /**\n   * Customize command help. Can be called multiple times to add more paragraphs and/or sections.\n   *\n   * @param text Help contents\n   * @param options Display options\n   */\n  help(text: string, options: Partial<CustomizedHelpOpts> = {}): Command {\n    customizeHelp(this, text, options)\n    return this\n  }\n\n  /**\n   * Configure some behavioral properties.\n   *\n   * @param props properties to set/update\n   */\n  configure(props: Partial<CommandConfig>): Command {\n    this._config.set(props)\n    return this\n  }\n\n  /**\n   * Get a configuration property value.\n   *\n   * @internal\n   * @param key Property key to get value for. See {@link CommandConfig}.\n   */\n  getConfigProperty<K extends keyof CommandConfig>(key: K): CommandConfig[K] {\n    return this._config.get(key)\n  }\n\n  /**\n   * Get the auto-casting flag.\n   *\n   * @internal\n   */\n  get autoCast(): boolean {\n    return (\n      this.getConfigProperty(\"autoCast\") ?? this.program.getConfigProperty(\"autoCast\")\n    )\n  }\n\n  /**\n   * Auto-complete\n   */\n  complete(completer: Completer): Command {\n    if (!this._lastAddedArgOrOpt) {\n      throw new Error(\n        \"Caporal setup error: you should only call `.complete()` after .argument() or .option().\",\n      )\n    }\n    registerCompletion(this._lastAddedArgOrOpt, completer)\n    return this\n  }\n\n  /**\n   * Toggle strict mode.\n   * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict }).\n   * By default, strict settings are not defined for commands, and inherit from the\n   * program settings. Calling `.strict(value)` on a command will override the program\n   * settings.\n   *\n   * @param strict boolean enabled flag\n   */\n  strict(strict = true): Command {\n    return this.configure({\n      strictArgsCount: strict,\n      strictOptions: strict,\n    })\n  }\n\n  /**\n   * Computed strictOptions flag.\n   *\n   * @internal\n   */\n  get strictOptions(): boolean {\n    return (\n      this.getConfigProperty(\"strictOptions\") ??\n      this.program.getConfigProperty(\"strictOptions\")\n    )\n  }\n  /**\n   * Computed strictArgsCount flag.\n   *\n   * @internal\n   */\n  get strictArgsCount(): boolean {\n    return (\n      this.getConfigProperty(\"strictArgsCount\") ??\n      this.program.getConfigProperty(\"strictArgsCount\")\n    )\n  }\n\n  /**\n   * Enable or disable auto casting of arguments & options for the command.\n   * This is basically a shortcut to calling `command.configure({ autoCast: enabled })`.\n   * By default, auto-casting is inherited from the program configuration.\n   * This method allows overriding what's been set on the program level.\n   *\n   * @param enabled\n   */\n  cast(enabled: boolean): Command {\n    return this.configure({ autoCast: enabled })\n  }\n\n  /**\n   * Visible flag\n   *\n   * @internal\n   */\n  get visible(): boolean {\n    return this.getConfigProperty(\"visible\")\n  }\n\n  /**\n   * Run the action associated with the command\n   *\n   * @internal\n   */\n  async run(parsed: Partial<ParserResult>): Promise<unknown> {\n    const data: ParserResult = {\n      args: [],\n      options: {},\n      line: \"\",\n      rawOptions: {},\n      rawArgv: [],\n      ddash: [],\n      ...parsed,\n    }\n\n    try {\n      // Validate args and options, including global options\n      const result = await validateCall(this, data)\n      const { args, options, ddash, errors } = result\n\n      // Process any global options\n      const shouldStop = await processGlobalOptions(result, this.program, this)\n      if (shouldStop) {\n        return -1\n      }\n\n      if (errors.length) {\n        throw new ValidationSummaryError(this, errors)\n      }\n\n      if (!this._action) {\n        throw new NoActionError(this)\n      }\n\n      return await this._action({\n        args,\n        options,\n        ddash,\n        logger,\n        program: this.program,\n        command: this,\n      })\n    } catch (err) {\n      const ctor = Object.getPrototypeOf(err).constructor.name\n      throw err instanceof BaseError && ctor !== \"Error\" ? err : new ActionError(err)\n    }\n  }\n}\n\n/**\n * Create a new command\n *\n * @internal\n */\nexport function createCommand(\n  ...args: ConstructorParameters<typeof Command>\n): InstanceType<typeof Command> {\n  return new Command(...args)\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport { ParserResult, ParserProcessedResult } from \"../types\"\nimport { validateArgs } from \"../argument/validate\"\nimport { validateOptions } from \"../option/validate\"\nimport type { Command } from \".\"\n\nexport async function validateCall(\n  cmd: Command,\n  result: ParserResult,\n): Promise<ParserProcessedResult> {\n  const { args: parsedArgs, options: parsedFlags } = result\n  // check if there are some global flags to handle\n  const { options: flags, errors: flagsErrors } = await validateOptions(cmd, parsedFlags)\n  const { args, errors: argsErrors } = await validateArgs(cmd, parsedArgs)\n  return { ...result, args, options: flags, errors: [...argsErrors, ...flagsErrors] }\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport path from \"path\"\nimport zipObject from \"lodash/zipObject\"\nimport map from \"lodash/map\"\nimport { readdir } from \"../utils/fs\"\nimport { importCommand } from \"./import\"\nimport { createCommand } from \".\"\nimport type { Command } from \".\"\nimport type { Program } from \"../program\"\n\nexport async function scanCommands(\n  program: Program,\n  dirPath: string,\n): Promise<Command[]> {\n  const files = await readdir(dirPath)\n  const imp = await Promise.all(files.map((f) => importCommand(path.join(dirPath, f))))\n  const data = zipObject(files, imp)\n  return map(data, (cmdBuilder, filename) => {\n    const { dir, name } = path.parse(filename)\n    const cmd = dir ? [...dir.split(\"/\"), name].join(\" \") : name\n    const options = {\n      createCommand: createCommand.bind(null, program, cmd),\n      program,\n    }\n    return cmdBuilder(options)\n  })\n}\n","/**\n * @packageDocumentation\n * @internal\n */\nimport glob from \"glob\"\nimport fs from \"fs\"\n\nexport function readdir(dirPath: string, extensions = \"js,ts\"): Promise<string[]> {\n  return new Promise((resolve, reject) => {\n    if (!fs.existsSync(dirPath)) {\n      return reject(new Error(`'${dirPath}' does not exist!`))\n    }\n    glob(`**/*.{${extensions}}`, { cwd: dirPath }, function (\n      err: Error | null,\n      files: string[],\n    ) {\n      /* istanbul ignore if */\n      if (err) {\n        return reject(err)\n      }\n      resolve(files)\n    })\n  })\n}\n","/**\n * @packageDocumentation\n * @module caporal/program\n */\nimport { EventEmitter } from \"events\"\nimport fs from \"fs\"\nimport path from \"path\"\nimport kebabCase from \"lodash/kebabCase\"\nimport mapKeys from \"lodash/mapKeys\"\nimport { createCommand, HELP_CMD, PROG_CMD } from \"../command\"\nimport { Command } from \"../command\"\nimport { findCommand } from \"../command/find\"\nimport { scanCommands } from \"../command/scan\"\nimport { createConfigurator } from \"../config\"\nimport { fatalError, UnknownOrUnspecifiedCommandError } from \"../error\"\nimport { customizeHelp } from \"../help\"\nimport { CustomizedHelpOpts } from \"../help/types\"\nimport { logger, setLogger } from \"../logger\"\nimport {\n  addGlobalOption,\n  createOption,\n  disableGlobalOption,\n  processGlobalOptions,\n  showHelp,\n} from \"../option\"\nimport { parseArgv } from \"../parser\"\nimport {\n  Action,\n  Logger,\n  Configurator,\n  ParserResult,\n  ParserTypes,\n  ProgramConfig,\n  CreateArgumentOpts,\n  CreateOptionProgramOpts,\n  CommandConfig,\n} from \"../types\"\nimport { CaporalValidator } from \"../types\"\nimport { detectVersion } from \"../utils/version\"\n\nconst LOG_LEVEL_ENV_VAR = \"CAPORAL_LOG_LEVEL\"\n// const SUPPORTED_SHELL = [\"bash\", \"zsh\", \"fish\"]\n\n/**\n * Program class\n *\n * @noInheritDoc\n */\nexport class Program extends EventEmitter {\n  private commands: Command[] = []\n  private _config: Configurator<ProgramConfig>\n  private _version?: string\n  private _name?: string\n  private _description?: string\n  private _programmaticMode = false\n  /**\n   * @internal\n   */\n  public defaultCommand?: Command\n  private _progCommand?: Command\n  private _bin: string\n  private _discoveryPath?: string\n  private _discoveredCommands?: Command[]\n\n  /**\n   * Number validator. Check that the value looks like a numeric one\n   * and cast the provided value to a javascript `Number`.\n   */\n  readonly NUMBER = CaporalValidator.NUMBER\n  /**\n   * String validator. Mainly used to make sure the value is a string,\n   * and prevent Caporal auto-casting of numerical values and boolean\n   * strings like `true` or `false`.\n   */\n  readonly STRING = CaporalValidator.STRING\n  /**\n   * Array validator. Convert any provided value to an array. If a string is provided,\n   * this validator will try to split it by commas.\n   */\n  readonly ARRAY = CaporalValidator.ARRAY\n  /**\n   * Boolean validator. Check that the value looks like a boolean.\n   * It accepts values like `true`, `false`, `yes`, `no`, `0`, and `1`\n   * and will auto-cast those values to `true` or `false`.\n   */\n  readonly BOOLEAN = CaporalValidator.BOOLEAN\n\n  /**\n   * Program constructor.\n   * - Detects the \"bin\" name from process argv\n   * - Detects the version from package.json\n   * - Set up the help command\n   * @ignore\n   */\n  constructor() {\n    super()\n    this._bin = path.basename(process.argv[1])\n    this._version = detectVersion()\n    this._config = createConfigurator({\n      strictArgsCount: true,\n      strictOptions: true,\n      autoCast: true,\n      logLevelEnvVar: LOG_LEVEL_ENV_VAR,\n    })\n    this.setupHelpCommand()\n    this.setupErrorHandlers()\n  }\n\n  /**\n   * @internal\n   */\n  private setupErrorHandlers(): void {\n    process.once(\"unhandledRejection\", (err) => {\n      if (this._programmaticMode) {\n        throw err\n      } else {\n        this.emit(\"error\", err)\n      }\n    })\n    this.on(\"error\", fatalError)\n  }\n\n  /**\n   * The program-command is the command attached directly to the program,\n   * meaning there is no command-keyword used to trigger it.\n   * Mainly used for programs executing only one possible action.\n   *\n   * @internal\n   */\n  get progCommand(): Command {\n    if (this._progCommand === undefined) {\n      this._progCommand = createCommand(this, PROG_CMD, \"\")\n    }\n    return this._progCommand\n  }\n\n  /**\n   * Setup the help command\n   */\n  private setupHelpCommand(): Command {\n    return this.command(HELP_CMD, \"Get help about a specific command\")\n      .argument(\n        \"[command]\",\n        \"Command name to get help for. If the command does not exist, global help will be displayed.\",\n      )\n      .action(async (actionParams) => {\n        const { args } = actionParams\n        const command = args.command\n          ? await findCommand(this, [args.command as string])\n          : undefined\n        // eslint-disable-next-line no-console\n        showHelp({ ...actionParams, command })\n        return -1\n      })\n      .hide()\n  }\n\n  /**\n   * Customize program help. Can be called multiple times to add more paragraphs and/or sections.\n   *\n   * @param text Help contents\n   * @param options Display options\n   */\n  help(text: string, options: Partial<CustomizedHelpOpts> = {}): Program {\n    customizeHelp(this, text, options)\n    return this\n  }\n\n  /**\n   * Toggle strict mode.\n   * Shortcut to calling: `.configure({ strictArgsCount: strict, strictOptions: strict })`.\n   * By default, the program is strict, so if you want to disable strict checking,\n   * just call `.strict(false)`. This setting can be overridden at the command level.\n   *\n   * @param strict boolean enabled flag\n   */\n  strict(strict = true): Program {\n    return this.configure({\n      strictArgsCount: strict,\n      strictOptions: strict,\n    })\n  }\n\n  /**\n   * Configure some behavioral properties.\n   *\n   * @param props properties to set/update\n   */\n  configure(props: Partial<ProgramConfig>): Program {\n    this._config.set(props)\n    return this\n  }\n\n  /**\n   * Get a configuration property value. {@link ProgramConfig Possible keys}.\n   *\n   * @param key Property\n   * @internal\n   */\n  getConfigProperty<K extends keyof ProgramConfig>(key: K): ProgramConfig[K] {\n    return this._config.get(key)\n  }\n\n  /**\n   * Return a reformatted synopsis string\n   *\n   * @internal\n   */\n  async getSynopsis(): Promise<string> {\n    return (\n      this.getBin() +\n      \" \" +\n      ((await this.hasCommands()) ? \"<command> \" : \"\") +\n      \"[ARGUMENTS...] [OPTIONS...]\"\n    ).trim()\n  }\n\n  /**\n   * Return the discovery path, if set\n   *\n   * @internal\n   */\n  get discoveryPath(): string | undefined {\n    return this._discoveryPath\n  }\n\n  /**\n   * Return the program version\n   *\n   * @internal\n   */\n  getVersion(): string | undefined {\n    return this._version\n  }\n\n  /**\n   * Set the version fo your program.\n   * You won't likely use this method as Caporal tries to guess it from your package.json\n   */\n  version(ver: string): Program {\n    this._version = ver\n    return this\n  }\n\n  /**\n   * Set the program name. If not set, the filename minus the extension will be used.\n   */\n  name(name: string): Program {\n    this._name = name\n    return this\n  }\n\n  /**\n   * Return the program name.\n   *\n   * @internal\n   */\n  getName(): string | undefined {\n    return this._name\n  }\n\n  /**\n   * Return the program description.\n   *\n   * @internal\n   */\n  getDescription(): string | undefined {\n    return this._description\n  }\n\n  /**\n   * Set the program description displayed in help.\n   */\n  description(desc: string): Program {\n    this._description = desc\n    return this\n  }\n\n  /**\n   * Get the bin name (the name of your executable).\n   *\n   * @internal\n   */\n  getBin(): string {\n    return this._bin\n  }\n\n  /**\n   * Sets the executable name. By default, it's auto-detected from the filename of your program.\n   *\n   * @param name Executable name\n   * @example\n   * ```ts\n   * program.bin('myprog')\n   * ```\n   */\n  bin(name: string): Program {\n    this._bin = name\n    return this\n  }\n\n  /**\n   * Set a custom logger for your program.\n   * Your logger should implement the {@link Logger} interface.\n   */\n  logger(logger: Logger): Program {\n    setLogger(logger)\n    return this\n  }\n\n  /**\n   * Disable a global option. Will warn if the global option\n   * does not exist of has already been disabled.\n   *\n   * @param name Name, short, or long notation of the option to disable.\n   */\n  disableGlobalOption(name: string): Program {\n    const disabled = disableGlobalOption(name)\n    if (!disabled) {\n      logger.warn(\n        \"Cannot disable global option %s. Either the global option does not exist or has already been disabled.\",\n      )\n    }\n    return this\n  }\n\n  /**\n   * Returns the list of all commands registered\n   * - By default, Caporal creates one: the \"help\" command\n   * - When calling argument() or action() on the program instance,\n   * Caporal also create what is called the \"program command\", which\n   * is a command directly attach to the program, usually used\n   * in mono-command programs.\n   * @internal\n   */\n  getCommands(): Command[] {\n    return this.commands\n  }\n\n  /**\n   * Add a command to the program.\n   *\n   * @param name Command name\n   * @param description Command description\n   * @example\n   * ```ts\n   * program.command('order', 'Order some food')\n   * ```\n   */\n  command(\n    name: string,\n    description: string,\n    config: Partial<CommandConfig> = {},\n  ): Command {\n    const cmd = createCommand(this, name, description, config)\n    this.commands.push(cmd)\n    return cmd\n  }\n\n  /**\n   * Check if the program has user-defined commands.\n   *\n   * @internal\n   * @private\n   */\n  async hasCommands(): Promise<boolean> {\n    return (await this.getAllCommands()).length > 1\n  }\n\n  /**\n   * @internal\n   */\n  async getAllCommands(): Promise<Command[]> {\n    const discoveredCommands = await this.scanCommands()\n    return [...this.commands, ...discoveredCommands]\n  }\n\n  /**\n   * Return the log level override, if any is provided using\n   * the right environment variable.\n   *\n   * @internal\n   * @private\n   */\n  public getLogLevelOverride(): string | undefined {\n    return process.env[this.getConfigProperty(\"logLevelEnvVar\")]\n  }\n\n  /**\n   * Enable or disable auto casting of arguments & options at the program level.\n   *\n   * @param enabled\n   */\n  cast(enabled: boolean): Program {\n    return this.configure({ autoCast: enabled })\n  }\n\n  /**\n   * Sets a *unique* action for the *entire* program.\n   *\n   * @param {Function} action - Action to run\n   */\n  action(action: Action): Program {\n    this.progCommand.action(action)\n    return this\n  }\n\n  /**\n   * Add an argument to the *unique* command of the program.\n   */\n  argument(\n    synopsis: string,\n    description: string,\n    options: CreateArgumentOpts = {},\n  ): Command {\n    return this.progCommand.argument(synopsis, description, options)\n  }\n\n  /**\n   * Add an option to the *unique* command of the program,\n   * or add a global option to the program when `options.global`\n   * is set to `true`.\n   *\n   * @param synopsis Option synopsis like '-f, --force', or '-f, --file \\<file\\>', or '--with-openssl [path]'\n   * @param description Option description\n   * @param options Additional parameters\n   */\n  option(\n    synopsis: string,\n    description: string,\n    options: CreateOptionProgramOpts = {},\n  ): Program {\n    if (options.global) {\n      const opt = createOption(synopsis, description, options)\n      addGlobalOption(opt, options.action)\n    } else {\n      this.progCommand.option(synopsis, description, options)\n    }\n    return this\n  }\n\n  /**\n   * Discover commands from a specified path.\n   *\n   * Commands must be organized into files (one command per file) in a file tree like:\n   *\n   * ```sh\n   * └── commands\n   *     ├── config\n   *     │   ├── set.ts\n   *     │   └── unset.ts\n   *     ├── create\n   *     │   ├── job.ts\n   *     │   └── service.ts\n   *     ├── create.ts\n   *     ├── describe.ts\n   *     └── get.ts\n   * ```\n   *\n   * The code above shows a short example of `kubectl` commands and subcommands.\n   * In this case, Caporal will generate the following commands:\n   *\n   * - kubectl get [args...] [options...]\n   * - kubectl config set [args...] [options...]\n   * - kubectl config unset [args...] [options...]\n   * - kubectl create [args...] [options...]\n   * - kubectl create job [args...] [options...]\n   * - kubectl create service [args...] [options...]\n   * - kubectl describe [args...] [options...]\n   * - kubectl get [args...] [options...]\n   *\n   * Notice how the `config` command has a mandatory subcommand associated,\n   * hence cannot be called without a subcommand, contrary to the `create` command.\n   * This is why there is no `config.ts` in the tree.\n   *\n   * @param path\n   */\n  discover(dirPath: string): Program {\n    let stat\n    try {\n      stat = fs.statSync(dirPath)\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n    if (!stat || !stat.isDirectory()) {\n      throw new Error(\n        \"Caporal setup error: parameter `dirPath` of discover() should be a directory\",\n      )\n    }\n\n    this._discoveryPath = dirPath\n    return this\n  }\n\n  /**\n   * Do a full scan of the discovery path to get all existing commands\n   * This should only be used to generate the full list of command,\n   * as for help rendering\n   *\n   * @private\n   */\n  private async scanCommands(): Promise<Command[]> {\n    if (this._discoveryPath === undefined) {\n      return []\n    }\n    if (this._discoveredCommands) {\n      return this._discoveredCommands\n    }\n    this._discoveredCommands = await scanCommands(this, this._discoveryPath)\n    return this._discoveredCommands\n  }\n\n  /* istanbul ignore next */\n  /**\n   * Reset all commands\n   *\n   * @internal\n   */\n  public reset(): Program {\n    this.commands = []\n    this._progCommand = undefined\n    this.setupHelpCommand()\n    return this\n  }\n\n  /**\n   * Run the program by parsing command line arguments.\n   * Caporal will automatically detect command line arguments from `process.argv` values,\n   * but it can be overridden by providing the `argv` parameter. It returns a Promise\n   * of the value returned by the *Action* triggered.\n   *\n   * ::: warning Be careful\n   * This method returns a `Promise`. You'll usually ignore the returned promise and call run() like this:\n   *\n   * ```ts\n   * [...]\n   * program.action(...)\n   * program.run()\n   * ```\n   *\n   * If you do add some `.catch()` handler to it, Caporal won't display any potential errors\n   * that the promise could reject, and will let you the responsibility to do it.\n   * :::\n   *\n   * @param argv Command line arguments to parse, default to `process.argv.slice(2)`.\n   */\n  async run(argv?: string[]): Promise<unknown> {\n    if (!argv) {\n      // used on web playground\n      if (process.env.CAPORAL_CMD_LINE) {\n        argv = process.env.CAPORAL_CMD_LINE.split(\" \").slice(1)\n        // defaut value for common usage\n      } else {\n        argv = process.argv.slice(2)\n      }\n    }\n\n    /*\n      Search for the command from args, then, if a default command exists,\n      take it, otherwise take the command attached to the program,\n      and lastly the help command/\n    */\n    const cmd = await this.findCommand(argv)\n\n    // parse command line args\n    const result = parseArgv(cmd?.getParserConfig(), argv)\n\n    /* \n      Run command with parsed args.\n      We are forced to catch a potential error to prevent the rejected\n      promise to propagate un in the stack. \n    */\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    return this._run(result, cmd) /*\n    .catch((e) => e) */\n  }\n\n  /**\n   * Try to find the executed command from argv\n   * If command cannot be found from argv, return the default command if any,\n   * then the program-command if any, or finally `undefined`.\n   * If argv is empty, and there is no defaultCommand or progCommand\n   * use the help command\n   *\n   * @param argv\n   */\n  private async findCommand(argv: string[]): ReturnType<typeof findCommand> {\n    return (await findCommand(this, argv)) || this.defaultCommand || this._progCommand\n  }\n\n  /**\n   * Run a command, providing parsed data\n   *\n   * @param result\n   * @param cmd\n   * @internal\n   */\n  private async _run(result: ParserResult, cmd?: Command): Promise<unknown> {\n    // Override logger level via ENV if needed\n    const loggerLevel = this.getLogLevelOverride()\n    if (loggerLevel && Object.keys(logger.levels).includes(loggerLevel)) {\n      logger.level = loggerLevel\n    }\n    // try to run the command\n    // try {\n    if (!cmd) {\n      // we may not have any associated command, but some global options may have been passed\n      // process them, if any\n      // Process any global options\n      const processedResult = { ...result, errors: [], args: {} }\n      const shouldStop = await processGlobalOptions(processedResult, this)\n      if (shouldStop) {\n        this.emit(\"run\")\n        return -1\n      }\n      // todo: use case: \"git unknown-command some args\" will display \"unknown command 'git'\"\n      // but should display \"unknown command 'git unknown-command'\"\n      throw new UnknownOrUnspecifiedCommandError(this, result.rawArgv[0])\n    }\n    const ret = await cmd.run(result)\n    this.emit(\"run\", ret)\n    return ret\n  }\n\n  /**\n   * Programmatic usage. Execute input command with given arguments & options\n   *\n   * Not ideal regarding type casting etc.\n   *\n   * @param args argv array\n   * @param options options object\n   * @param ddash double dash array\n   * @public\n   */\n  async exec(\n    args: string[],\n    options: Record<string, ParserTypes> = {},\n    ddash: string[] = [],\n  ): Promise<unknown> {\n    this._programmaticMode = true\n    const cmd = await this.findCommand(args)\n    options = mapKeys(options, (v, key) => kebabCase(key))\n    return this._run(\n      {\n        args,\n        options,\n        line: args.join(\" \"),\n        rawOptions: options,\n        rawArgv: args,\n        ddash,\n      },\n      cmd,\n    )\n  }\n}\n","/**\n * Main Caporal module.\n *\n * ## program\n *\n * This represents your program. You don't have to instanciate the {@link Program} class,\n * it's already done for you.\n *\n * **Usage**\n *\n * ```ts\n * // The Program instance generated for you\n * import program from \"@caporal/core\"\n *\n * program\n *  .command(...)\n *  .action(...)\n * [...]\n * ```\n *\n *\n * ## parseArgv()\n *\n *  This is the command line parser internaly used by Caporal.\n *\n * ::: tip Advanced usage\n * Usually, **you won't need to use the parser** directly, but if you\n * just want to parse some args without all capabilities brought\n * by Caporal, feel free to play with it.\n * :::\n *\n * **Usage**\n *\n * ```ts\n * import { parseArgv } from \"@caporal/core\"\n *\n * const {args, options} = parseArgv({\n *  // ... options\n * })\n * ```\n *\n * Checkout `parseArgv()` [documentation here](/api/modules/parser.md).\n *\n *\n * ## chalk\n *\n * `chalk` npm module re-export\n *\n * **Usage**\n *\n * ```ts\n * import { program, chalk } from \"caporal\"\n *\n * program\n *  .command('pay')\n *  .argument('<amount>', 'Amount to pay', Validator.NUMBER)\n *  .action(({logger, args}) => {\n *    logger.info(\"You paid $%s\", chalk.red(args.amount))\n *  })\n * [...]\n * ```\n *\n *\n * @packageDocumentation\n * @module @caporal/core\n */\nimport { Program } from \"./program\"\nexport { Command } from \"./command\"\nexport * from \"./types\"\n\n/**\n * @ignore\n */\nexport { default as chalk } from \"chalk\"\n/**\n * @ignore\n */\nexport { parseArgv, parseLine } from \"./parser\"\n\n/**\n * @ignore\n */\nexport { registerTemplate } from \"./help\"\nexport type { Template, TemplateFunction, TemplateContext } from \"./help/types\"\n\n/**\n * @ignore\n */\nexport const program = new Program()\n\n/**\n * @ignore\n */\nexport default program\n\n/**\n * @ignore\n */\nexport { Program }\n"],"sourceRoot":""}